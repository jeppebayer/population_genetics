#!/bin/env python3
from gwf import AnonymousTarget
import os, glob

########################## Functions ##########################

def species_abbreviation(species_name: str) -> str:
	"""Creates species abbreviation from species name.

	:param str species_name:
		Species name written as *genus* *species*"""
	genus, species = species_name.replace(' ', '_').split('_')
	genus = genus[0].upper() + genus[1:3]
	species = species[0].upper() + species[1:3]
	return genus + species

def parse_fasta(fasta_file: str):
    """
    Parses :format:`FASTA` file returning all sequence names and lengths paired in a list of dictionaries.
    
    ::
    
        return [{'sequence_name': str, 'sequence_length': int}, ...]
    
    :param str fasta_file:
        Sequence file in :format:`FASTA` format.
    """
    fasta_list = []
    seq_name = None
    length = 0
    with open(fasta_file, 'r') as fasta:
        for entry in fasta:
            entry = entry.strip()
            if entry.startswith(">"):
                if seq_name:
                    fasta_list.append({'sequence_name': seq_name, 'sequence_length': length})
                    length = 0
                entry = entry.split(" ", 1)
                seq_name = entry[0][1:]
            else:
                length += len(entry)
        fasta_list.append({'sequence_name': seq_name, 'sequence_length': length})
    return fasta_list

def padding_calculator(parse_fasta: list, size: int = 500000):
    """
    Calculates proper 0 padding for numbers in **partition_chrom**.

    :param list parse_fasta:
        List of dictionaries produced by **parse_fasta**.
    :param int size:
        Size of partitions. Default 500kb.
    """
    num = 1
    for chrom in parse_fasta:
        whole_chunks = chrom['sequence_length'] // size
        num += (whole_chunks + 1)
    return len(str(num))

def partition_chrom(parse_fasta: list, size: int = 500000, npad: int = 5):
    """
    Partitions :format:`FASTA` file parsed with **parse_fasta**.
    
    Uses the list of dictionaries from **parse_fasta** to creates a list of dictionaries
    containing partition number, sequence name, start and end postion (0 based).
    By default the partition size is 500kbs.
    
    ::
    
        return [{'num': int, 'region': str, 'start': int, 'end': int}, ...]
    
    :param list parse_fasta:
        List of dictionaries produced by **parse_fasta**.
    :param int size:
        Size of partitions. Default 500kb.
    """
    chrom_partition = []
    num = 1
    for chrom in parse_fasta:
        whole_chunks = chrom['sequence_length'] // size
        partial_chunk = chrom['sequence_length'] - whole_chunks * size
        start = 0
        for chunk in range(whole_chunks):
            end = start + size
            chrom_partition.append({'num': f'{num:0{npad}}', 'region': chrom['sequence_name'], 'start': start, 'end': end})
            start = end
            num += 1
        chrom_partition.append({'num': f'{num:0{npad}}', 'region': chrom['sequence_name'], 'start': start, 'end': start + partial_chunk})
        num += 1
    return chrom_partition

def mpileup_partitions_filelist(partitions: list, top_dir: str, species_name: str, npad: int = 5):
    """
    Generates list of dictionaries containing names of contigs and filenames of :format:`mpileup`-parts per contig based on **partition_chrom** output.

    Uses the list of dictionaries generated by **partition_chrom** to create a list of dictionaries where each dictionary contains the name of a contig
    and the names of output files created **mpileup_part** using those same partitions.

    ::

        return [{'contig': str, 'mpileup_files': list}, ...]
    
    :param list partitions:
        List of dictionaries produced by **partition_chrom**.
    :param str top_dir:
        Top most level of current working directory.
    :param str species_name:
        Name of species currently being worked on.
    """
    mpileup_filelists = []
    contig_name = None
    part_num = 0
    for partition in partitions:
        part_num += 1
        if partition['region'] != contig_name:
            if contig_name:
                mpileup_filelists.append({'contig': contig_name, 'mpileup_files': [f'{top_dir}/tmp/mpileup/{species_abbreviation(species_name)}_{num:0{npad}}_{contig_name}.mpileup' for num in range(start, part_num)]})
            start = part_num
            contig_name = partition['region']
    mpileup_filelists.append({'contig': contig_name, 'mpileup_files': [f'{top_dir}/tmp/mpileup/{species_abbreviation(species_name)}_{num:0{npad}}_{contig_name}.mpileup' for num in range(start, part_num + 1)]})
    return mpileup_filelists

########################## Freebayes ##########################

def name_freebayes_chrom(idx: str, target: AnonymousTarget) -> str:
	return f'{os.path.basename(target.outputs["vcf"].replace("-", "_"))}'

# def freebayes_chrom(reference_genome_file: str, bam_file_list: list, output_directory: str, species_name: str, region: str, num: int, start: int, end: int, ploidy: int = 100, best_n_alleles: int = 3, min_alternate_fraction: float | int = 0, min_alternate_count: int = 2):
# 	"""
# 	Template: Create VCF file for each 'chromosome' in pooled alignment.
	
# 	Template I/O::
	
# 		inputs = {}
# 		outputs = {}
	
# 	:param
# 	"""
# 	bam_file_string = ' -b '.join(bam_file_list)
# 	inputs = {'reference': reference_genome_file,
# 		   	  'bam': bam_file_list}
# 	outputs = {'vcf': f'{output_directory}/freebayes_vcf/tmp/{species_abbreviation(species_name)}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.vcf'}
# 	options = {
# 		'cores': 1,
# 		'memory': '100g',
# 		'walltime': '36:00:00'
# 	}
# 	spec = f"""
# 	# Sources environment
# 	if [ "$USER" == "jepe" ]; then
# 		source /home/"$USER"/.bashrc
# 		source activate vcf
# 	fi
	
# 	export _JAVA_OPTIONS="-Xmx{options['memory']}"

# 	echo "START: $(date)"
# 	echo "JobID: $SLURM_JOBID"

# 	[ -d {output_directory}/freebayes_vcf/tmp ] || mkdir -p {output_directory}/freebayes_vcf/tmp
	
# 	freebayes \
# 		-f {reference_genome_file} \
# 		-n {best_n_alleles} \
# 		-p {ploidy} \
# 		-r {region}:{start}-{end} \
# 		--min-alternate-fraction {min_alternate_fraction} \
# 		--min-alternate-count {min_alternate_count} \
# 		--pooled-discrete \
#         -b {bam_file_string} \
# 	| bcftools filter \
# 		-e 'INFO/TYPE~"del" || INFO/TYPE~"ins"' \
# 		-O v \
# 		- \
# 		> {output_directory}/freebayes_vcf/tmp/{species_abbreviation(species_name)}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.prog.vcf
	
# 	mv {output_directory}/freebayes_vcf/tmp/{species_abbreviation(species_name)}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.prog.vcf {outputs['vcf']}
	
# 	echo "END: $(date)"
# 	echo "$(jobinfo "$SLURM_JOBID")"
# 	"""
# 	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def freebayes_chrom(reference_genome_file: str, bam_file_list: list, output_directory: str, species_name: str, region: str, num: int, start: int, end: int, ploidy: int = 100, best_n_alleles: int = 3, min_alternate_fraction: float | int = 0, min_alternate_count: int = 2):
	"""
	Template: Create VCF file for each 'chromosome' in pooled alignment.
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	bam_file_string = ' -b '.join(bam_file_list)
	inputs = {'reference': reference_genome_file,
		   	  'bam': bam_file_list}
	outputs = {'vcf': f'{output_directory}/freebayes_vcf/tmp/{species_abbreviation(species_name)}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.vcf'}
	options = {
		'cores': 1,
		'memory': '80g',
		'walltime': '60:00:00'
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	export _JAVA_OPTIONS="-Xmx{options['memory']}"

	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"

	[ -d {output_directory}/freebayes_vcf/tmp ] || mkdir -p {output_directory}/freebayes_vcf/tmp
	
	freebayes \
		-f {reference_genome_file} \
		-n {best_n_alleles} \
		-p {ploidy} \
		-r {region}:{start}-{end} \
		--min-alternate-fraction {min_alternate_fraction} \
		--min-alternate-count {min_alternate_count} \
		--pooled-discrete \
        -b {bam_file_string} \
	    > {output_directory}/freebayes_vcf/tmp/{species_abbreviation(species_name)}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.prog.vcf
	
	mv {output_directory}/freebayes_vcf/tmp/{species_abbreviation(species_name)}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.prog.vcf {outputs['vcf']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def freebayes_chrom_single_sample(reference_genome_file: str, bam_file: str, output_directory: str, sample_name: str, region: str, num: int, start: int, end: int, ploidy: int = 100, best_n_alleles: int = 3, min_alternate_fraction: float | int = 0, min_alternate_count: int = 2):
	"""
	Template: Create VCF file for each 'chromosome' in pooled alignment.
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'reference': reference_genome_file,
		   	  'bam': bam_file}
	outputs = {'vcf': f'{output_directory}/tmp/{sample_name}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.vcf'}
	options = {
		'cores': 1,
		'memory': '80g',
		'walltime': '60:00:00'
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	export _JAVA_OPTIONS="-Xmx{options['memory']}"

	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"

	[ -d {output_directory}/tmp ] || mkdir -p {output_directory}/tmp
	
	freebayes \
		-f {reference_genome_file} \
		-n {best_n_alleles} \
		-p {ploidy} \
		-r {region}:{start}-{end} \
		--min-alternate-fraction {min_alternate_fraction} \
		--min-alternate-count {min_alternate_count} \
		--pooled-discrete \
        -b {bam_file} \
	    > {output_directory}/tmp/{sample_name}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.prog.vcf
	
	mv {output_directory}/tmp/{sample_name}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.prog.vcf {outputs['vcf']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def concat(files: list, output_name: str, output_directory: str = None, compress: bool = False):
    """
    Template: Name-sorts and concatenates files. Optionally compresses output using :script:`gzip`.
    
    Template I/O::
    
        inputs = {'files': files}
        outputs = {'concat_file': output_name.ext | output_name.ext.gzip}
    
    :param list files:
        List containing files to concatenate.
    :param str output_name:
        Desired name of output file, no extension.
    :param str output_directory:
        Path to output directory. Default is directory of 'files[0]'.
    :param bool compress:
        Bool indicating whether the output file should be compressed or not.
    """
    if output_directory is None:
        output_directory = os.path.dirname(files[0])
    inputs = {'files': files}
    if compress:
        outputs = {'concat_file': f'{output_directory}/{output_name}{os.path.splitext(files[0])[1]}.gz'}
    else:
        outputs = {'concat_file': f'{output_directory}/{output_name}{os.path.splitext(files[0])[1]}'}
    options = {
        'cores': 2,
        'memory': '16g',
        'walltime': '24:00:00'
    }
    protect = outputs['concat_file']
    spec = f"""
    # Sources environment
    if [ "$USER" == "jepe" ]; then
        source /home/"$USER"/.bashrc
        source activate popgen
    fi
    
    echo "START: $(date)"
    echo "JobID: $SLURM_JOBID"
    
    [ -d {output_directory}] || mkdir -p {output_directory}

    if [ {compress} == 'False' ]; then
        cat \
            {' '.join(files)} \
            > {output_directory}/{output_name}.prog{os.path.splitext(files[0])[1]}
        
        mv {output_directory}/{output_name}.prog{os.path.splitext(files[0])[1]} {outputs['concat_file']}
    else
        cat \
            {' '.join(files)} \
        | gzip \
            -c \
            - \
            > {output_directory}/{output_name}.prog{os.path.splitext(files[0])[1]}.gz
        
        mv {output_directory}/{output_name}.prog{os.path.splitext(files[0])[1]}.gz {outputs['concat_file']}
    fi

    echo "END: $(date)"
    echo "$(jobinfo "$SLURM_JOBID")"
    """
    return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, protect=protect, spec=spec)

def concat_vcf(files: list, output_name: str, output_directory: str = None, compress: bool = False):
    """
    Template: Concatenates :format:`VCF` files. Optionally compresses output.
    
    Template I/O::
    
        inputs = {'files': files}
        outputs = {'concat_file': output_name.ext | output_name.ext.gzip}
    
    :param list files:
        List containing :format:`VCF` files to concatenate. Can already be gzipped.
    :param str output_name:
        Desired name of output file, no extension.
    :param str output_directory:
        Path to output directory. Default is directory of 'files[0]'.
    :param bool compress:
        Bool indicating whether the output file should be compressed or not.
    """
    if not output_directory:
        output_directory = os.path.dirname(files[0])
    inputs = {'files': files}
    if compress:
        outputs = {'concat_file': f'{output_directory}/{output_name}.vcf.gz'}
    else:
        outputs = {'concat_file': f'{output_directory}/{output_name}.vcf'}
    options = {
        'cores': 32,
        'memory': '40g',
        'walltime': '24:00:00'
    }
    protect = outputs['concat_file']
    spec = f"""
    # Sources environment
    if [ "$USER" == "jepe" ]; then
        source /home/"$USER"/.bashrc
        source activate popgen
    fi
    
    echo "START: $(date)"
    echo "JobID: $SLURM_JOBID"
    
    [ -d {output_directory} ] || mkdir -p {output_directory}
    
    if [ {compress} == 'False' ]; then
        bcftools concat \
            --threads {options['cores']} \
            --output-type v \
            --output {output_directory}/{output_name}.prog.vcf \
            {' '.join(files)}

            mv {output_directory}/{output_name}.prog.vcf {outputs['concat_file']}
    else
        bcftools concat \
            --threads {options['cores']} \
            --output-type z9 \
            --output {output_directory}/{output_name}.prog.vcf.gz \
            {' '.join(files)}

            mv {output_directory}/{output_name}.prog.vcf.gz {outputs['concat_file']}
    fi
    
    echo "END: $(date)"
    echo "$(jobinfo "$SLURM_JOBID")"
    """
    return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, protect=protect, spec=spec)