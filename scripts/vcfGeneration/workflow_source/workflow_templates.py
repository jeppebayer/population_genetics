#!/bin/env python3
from gwf import AnonymousTarget
import os, glob

########################## Functions ##########################

def species_abbreviation(speciesName: str) -> str:
	"""Creates species abbreviation from species name.

	:param str speciesName:
		Species name written as *genus* *species*"""
	genus, species = speciesName.replace(' ', '_').split('_')
	genus = genus[0].upper() + genus[1:3]
	species = species[0].upper() + species[1:3]
	return genus + species

def parse_fasta(fastaFile: str):
	"""
	Parses :format:`FASTA` file returning all sequence names and lengths paired in a list of dictionaries.
	
	::
	
		return [{'sequence_name': str, 'sequence_length': int}, ...]
	
	:param str fastaFile:
		Sequence file in :format:`FASTA` format.
	"""
	fastaList = []
	seqName = None
	length = 0
	with open(fastaFile, 'r') as fasta:
		for entry in fasta:
			entry = entry.strip()
			if entry.startswith(">"):
				if seqName:
					fastaList.append({'sequence_name': seqName, 'sequence_length': length})
					length = 0
				entry = entry.split(" ", 1)
				seqName = entry[0][1:]
			else:
				length += len(entry)
		fastaList.append({'sequence_name': seqName, 'sequence_length': length})
	return fastaList

def padding_calculator(parseFasta: list, size: int  | None = 500000):
	"""
	Calculates proper 0 padding for numbers in **partition_chrom**.

	:param list parseFasta:
		List of dictionaries produced by **parse_fasta**.
	:param int size:
		Size of partitions. Default 500kb.
	"""
	num = 1
	for chrom in parseFasta:
		wholeChunks = chrom['sequence_length'] // size
		num += (wholeChunks + 1)
	return len(str(num))

def partition_chrom(parseFasta: list, size: int = 500000, nPad: int = 5):
	"""
	Partitions :format:`FASTA` file parsed with **parse_fasta**.
	
	Uses the list of dictionaries from **parse_fasta** to creates a list of dictionaries
	containing partition number, sequence name, start and end postion (0 based).
	By default the partition size is 500kbs.
	
	::
	
		return [{'num': int, 'region': str, 'start': int, 'end': int}, ...]
	
	:param list parseFasta:
		List of dictionaries produced by **parse_fasta**.
	:param int size:
		Size of partitions. Default 500kb.
	"""
	chromPartition = []
	num = 1
	for chrom in parseFasta:
		wholeChunks = chrom['sequence_length'] // size
		partialChunk = chrom['sequence_length'] - wholeChunks * size
		start = 0
		for chunk in range(wholeChunks):
			end = start + size
			chromPartition.append({'num': f'{num:0{nPad}}', 'region': chrom['sequence_name'], 'start': start, 'end': end})
			start = end
			num += 1
		if partialChunk:
			chromPartition.append({'num': f'{num:0{nPad}}', 'region': chrom['sequence_name'], 'start': start, 'end': start + partialChunk})
			num += 1
	return chromPartition

def mpileup_partitions_filelist(partitions: list, topDir: str, speciesName: str, nPad: int = 5):
	"""
	Generates list of dictionaries containing names of contigs and filenames of :format:`mpileup`-parts per contig based on **partition_chrom** output.

	Uses the list of dictionaries generated by **partition_chrom** to create a list of dictionaries where each dictionary contains the name of a contig
	and the names of output files created **mpileup_part** using those same partitions.

	::

		return [{'contig': str, 'mpileup_files': list}, ...]
	
	:param list partitions:
		List of dictionaries produced by **partition_chrom**.
	:param str topDir:
		Top most level of current working directory.
	:param str speciesName:
		Name of species currently being worked on.
	"""
	mpileupFilelists = []
	contigName = None
	partNum = 0
	for partition in partitions:
		partNum += 1
		if partition['region'] != contigName:
			if contigName:
				mpileupFilelists.append({'contig': contigName, 'mpileup_files': [f'{topDir}/tmp/mpileup/{species_abbreviation(speciesName)}_{num:0{nPad}}_{contigName}.mpileup' for num in range(start, partNum)]})
			start = partNum
			contigName = partition['region']
	mpileupFilelists.append({'contig': contigName, 'mpileup_files': [f'{topDir}/tmp/mpileup/{species_abbreviation(speciesName)}_{num:0{nPad}}_{contigName}.mpileup' for num in range(start, partNum + 1)]})
	return mpileupFilelists

########################## Freebayes ##########################

def name_freebayes_chrom(idx: str, target: AnonymousTarget) -> str:
	return f'{os.path.basename(target.outputs["vcf"].replace("-", "_"))}'

# def freebayes_chrom(referenceGenomeFile: str, bamFileList: list, outputDirectory: str, speciesName: str, region: str, num: int, start: int, end: int, ploidy: int = 100, bestNAlleles: int = 3, minAlternateFraction: float | int = 0, minAlternateCount: int = 2):
# 	"""
# 	Template: Create VCF file for each 'chromosome' in pooled alignment.
	
# 	Template I/O::
	
# 		inputs = {}
# 		outputs = {}
	
# 	:param
# 	"""
# 	bamFileString = ' -b '.join(bamFileList)
# 	inputs = {'reference': referenceGenomeFile,
# 		   	  'bam': bamFileList}
# 	outputs = {'vcf': f'{outputDirectory}/freebayes_vcf/tmp/{species_abbreviation(speciesName)}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region}.vcf'}
# 	options = {
# 		'cores': 1,
# 		'memory': '100g',
# 		'walltime': '36:00:00'
# 	}
# 	spec = f"""
# 	# Sources environment
# 	if [ "$USER" == "jepe" ]; then
# 		source /home/"$USER"/.bashrc
# 		source activate vcf
# 	fi
	
# 	export _JAVA_OPTIONS="-Xmx{options['memory']}"

# 	echo "START: $(date)"
# 	echo "JobID: $SLURM_JOBID"

# 	[ -d {outputDirectory}/freebayes_vcf/tmp ] || mkdir -p {outputDirectory}/freebayes_vcf/tmp
	
# 	freebayes \\
# 		-f {referenceGenomeFile} \\
# 		-n {bestNAlleles} \\
# 		-p {ploidy} \\
# 		-r {region}:{start}-{end} \\
# 		--min-alternate-fraction {minAlternateFraction} \\
# 		--min-alternate-count {minAlternateCount} \\
# 		--pooled-discrete \\
#         -b {bamFileString} \\
# 	| bcftools filter \\
# 		-e 'INFO/TYPE~"del" || INFO/TYPE~"ins"' \\
# 		-O v \\
# 		- \\
# 		> {outputDirectory}/freebayes_vcf/tmp/{species_abbreviation(speciesName)}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region}.prog.vcf
	
# 	mv {outputDirectory}/freebayes_vcf/tmp/{species_abbreviation(speciesName)}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region}.prog.vcf {outputs['vcf']}
	
# 	echo "END: $(date)"
# 	echo "$(jobinfo "$SLURM_JOBID")"
# 	"""
# 	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def freebayes_chrom(referenceGenomeFile: str, bamFileList: list, outputDirectory: str, speciesName: str, region: str, num: int, start: int, end: int, ploidy: int = 100, bestNAlleles: int = 3, minAlternateFraction: float | int = 0, minAlternateCount: int = 2):
	"""
	Template: Create VCF file for each 'chromosome' in pooled alignment.
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	bamFileString = ' -b '.join(bamFileList)
	inputs = {'reference': referenceGenomeFile,
		   	  'bam': bamFileList}
	outputs = {'vcf': f'{outputDirectory}/freebayes_vcf/tmp/{species_abbreviation(speciesName)}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region}.vcf'}
	options = {
		'cores': 1,
		'memory': '80g',
		'walltime': '60:00:00'
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	export _JAVA_OPTIONS="-Xmx{options['memory']}"

	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"

	[ -d {outputDirectory}/freebayes_vcf/tmp ] || mkdir -p {outputDirectory}/freebayes_vcf/tmp
	
	freebayes \\
		-f {referenceGenomeFile} \\
		-n {bestNAlleles} \\
		-p {ploidy} \\
		-r {region}:{start}-{end} \\
		--min-alternate-fraction {minAlternateFraction} \\
		--min-alternate-count {minAlternateCount} \\
		--pooled-discrete \\
		-b {bamFileString} \\
		> {outputDirectory}/freebayes_vcf/tmp/{species_abbreviation(speciesName)}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region}.prog.vcf
	
	mv {outputDirectory}/freebayes_vcf/tmp/{species_abbreviation(speciesName)}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region}.prog.vcf {outputs['vcf']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def index_reference_genome(referenceGenomeFile: str, outputDirectory: str):
	"""
	Template: Index reference genome with :script:`bwa index` and :script:`samtools faidx`.
	
	Template I/O::
	
		inputs = {'reference': referenceGenomeFile}
		outputs = {'symlink': *, 'bwa': [*.amb, *.ann, *.pac, *.bwt, *.sa], 'fai': *.fai}
	
	:param str referenceGenomeFile:
		Path to reference genome.
	:param str outputDirectory:
		Path to output directory.
	"""
	inputs = {'reference': referenceGenomeFile}
	outputs = {'symlink': f'{outputDirectory}/reference/{os.path.basename(referenceGenomeFile)}',
			   'bwa': [f'{outputDirectory}/reference/{os.path.basename(referenceGenomeFile)}.amb',
					   f'{outputDirectory}/reference/{os.path.basename(referenceGenomeFile)}.ann',
					   f'{outputDirectory}/reference/{os.path.basename(referenceGenomeFile)}.pac',
					   f'{outputDirectory}/reference/{os.path.basename(referenceGenomeFile)}.bwt',
					   f'{outputDirectory}/reference/{os.path.basename(referenceGenomeFile)}.sa'],
			   'fai': f'{outputDirectory}/reference/{os.path.basename(referenceGenomeFile)}.fai'}
	protect = [outputs['symlink'], outputs['bwa'][0], outputs['bwa'][1], outputs['bwa'][2], outputs['bwa'][3], outputs['bwa'][4], outputs['fai']]
	options = {
		'cores': 1,
		'memory': '10g',
		'walltime': '04:00:00'
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {outputDirectory}/reference ] || mkdir -p {outputDirectory}/reference
	[ -e {outputDirectory}/reference/{os.path.basename(referenceGenomeFile)} ] && rm -f {outputDirectory}/reference/{os.path.basename(referenceGenomeFile)}
	ln -s {referenceGenomeFile} {outputDirectory}/reference/{os.path.basename(referenceGenomeFile)}
	
	bwa index \\
		-p {outputDirectory}/reference/{os.path.basename(referenceGenomeFile)} \\
		{outputDirectory}/reference/{os.path.basename(referenceGenomeFile)}
	
	samtools faidx \\
		-o {outputDirectory}/reference/{os.path.basename(referenceGenomeFile)}.prog.fai \\
		{outputDirectory}/reference/{os.path.basename(referenceGenomeFile)}
	
	mv {outputDirectory}/reference/{os.path.basename(referenceGenomeFile)}.prog.fai {outputs['fai']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, protect=protect, options=options, spec=spec)

def depth_distribution(bamFiles: list, minCoverageThreshold: int, mode: int, entryName: str, outputDirectory: str, outputName: str, depthDistribution: str = f'{os.path.dirname(os.path.realpath(__file__))}/software/depthDistribution.py'):
	"""
	Template: Calculate the per site depth distribution across all populations using :script:`samtools depth`.
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'bam': bamFiles}
	outputs = {'tsv': f'{outputDirectory}/depth/{outputName}.tsv',
			   'plot': f'{outputDirectory}/depth/{outputName}.png'}
	protect = [outputs['tsv'], outputs['plot']]
	options = {
		'cores': 30,
		'memory': '50g',
		'walltime': '18:00:00'
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {outputDirectory}/depth ] || mkdir -p {outputDirectory}/depth
	
	samtools depth \\
		--threads {options['cores'] - 1} \\
		{' '.join(bamFiles)} \\
	| python {depthDistribution} \\
		- \\
		{minCoverageThreshold} \\
		{mode} \\
		{entryName} \\
		{outputDirectory}/depth \\
		{outputName}.prog

	mv {outputDirectory}/depth/{outputName}.prog.tsv {outputs['tsv']}
	mv {outputDirectory}/depth/{outputName}.prog.png {outputs['plot']}

	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, protect=protect, options=options, spec=spec)

def shared_sites_within_threshold_bed(bamFiles: list, depthDistributionTsv: str, outputDirectory: str, outputName: str):
	"""
	Template: template_description
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'bamFiles': bamFiles,
		   	  'depthTsv': depthDistributionTsv}
	outputs = {'bed': f'{outputDirectory}/depth/{outputName}.depththreshold.bed'}
	options = {
		'cores': 20,
		'memory': '30g',
		'walltime': '10:00:00'
	}
	protect = [outputs['bed']]
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {outputDirectory}/depth ] || mkdir -p {outputDirectory}/depth
	
	bedtools merge \\
		-i <(samtools depth \\
			--threads {options['cores'] - 1} \\
			{' '.join(bamFiles)} \\
		| awk \\
			-v maxthreshold=$(awk \\
				'BEGIN{{
					FS = OFS = "\\t"
				}}
				{{
					if (NR == 2) 
					{{
						print $7
						exit
					}}
				}}' \\
				{depthDistributionTsv}) \\
			-v minthreshold=$(awk \\
				'BEGIN{{
					FS = OFS = "\\t"
				}}
				{{
					if (NR == 2)
					{{
						print $6
						exit
					}}
				}}' \\
				{depthDistributionTsv}) \\
			'BEGIN{{
				FS = OFS = "\\t"
			}}
			{{
				checksum = 0
				for (i = 3; i <= NF; i++)
				{{
					if ($i >= minthreshold && $i <= maxthreshold)
						{{checksum += 1}}
				}}
				f (checksum == NF - 2)
				{{
					print $1, $2 - 1, $2
				}}
			}}' \\
		) \\
		> {outputDirectory}/depth/{outputName}.depththreshold.prog.bed
	
	mv {outputDirectory}/depth/{outputName}.depththreshold.prog.bed {outputs['bed']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, protect=protect, spec=spec)

def name_freebayes_partition_single(idx: str, target: AnonymousTarget) -> str:
	return f'freebayes_part_single_{os.path.basename(target.outputs["vcf"]).replace("-", "_").replace("|", "_")}'

def freebayes_partition_single(referenceGenomeFile: str, bamFile: str, outputDirectory: str, groupName: str, sampleName: str, region: str, num: int, start: int, end: int, ploidy: int = 100, bestNAlleles: int = 3, minAlternateFraction: float | int = 0, minAlternateCount: int = 2, memory: int = 80, time: str = '48:00:00'):
	"""
	Template: Create VCF file for each partition in a single pooled alignment.
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'reference': referenceGenomeFile,
		   	  'bam': bamFile}
	outputs = {'vcf': f'{outputDirectory}/raw_vcf/{groupName}/{sampleName}/tmp/{sampleName}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region.replace("|", "_")}.vcf.gz',
			   'index': f'{outputDirectory}/raw_vcf/{groupName}/{sampleName}/tmp/{sampleName}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region.replace("|", "_")}.vcf.gz.csi'}
	options = {
		'cores': 1,
		'memory': f'{memory}g',
		'walltime': time
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	export _JAVA_OPTIONS="-Xmx{options['memory']}"

	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"

	[ -d {outputDirectory}/raw_vcf/{groupName}/{sampleName}/tmp ] || mkdir -p {outputDirectory}/raw_vcf/{groupName}/{sampleName}/tmp
	
	freebayes \\
		--fasta-reference {referenceGenomeFile} \\
		--use-best-n-alleles {bestNAlleles} \\
		--ploidy {ploidy} \\
		--region '{region}:{start}-{end}' \\
		--min-alternate-fraction {minAlternateFraction} \\
		--min-alternate-count {minAlternateCount} \\
		--pooled-discrete \\
		-b {bamFile} \\
	| bcftools view \\
		--output-type z \\
		--output {outputDirectory}/raw_vcf/{groupName}/{sampleName}/tmp/{sampleName}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region.replace("|", "_")}.prog.vcf.gz \\
		--write-index \\
		-
	
	mv {outputDirectory}/raw_vcf/{groupName}/{sampleName}/tmp/{sampleName}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region.replace("|", "_")}.prog.vcf.gz {outputs['vcf']}
	mv {outputDirectory}/raw_vcf/{groupName}/{sampleName}/tmp/{sampleName}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region.replace("|", "_")}.prog.vcf.gz.csi {outputs['index']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def name_freebayes_partition_group(idx: str, target: AnonymousTarget) -> str:
	return f'freebayes_part_group_{os.path.basename(target.outputs["vcf"]).replace("-", "_").replace("|", "_")}'

def freebayes_partition_group(referenceGenomeFile: str, bamFiles: list, outputDirectory: str, speciesName: str, groupName: str, region: str, num: int, start: int, end: int, ploidy: int = 100, bestNAlleles: int = 3, minAlternateFraction: float | int = 0, minAlternateCount: int = 2, memory: int = 80, time: str = '48:00:00'):
	"""
	Template: Create VCF file for each partition in a group of pooled alignments.
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'reference': referenceGenomeFile,
		   	  'bam': bamFiles}
	outputs = {'vcf': f'{outputDirectory}/raw_vcf/{groupName}/tmp/{species_abbreviation(speciesName)}_{groupName}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region.replace("|", "_")}.vcf.gz',
			   'index': f'{outputDirectory}/raw_vcf/{groupName}/tmp/{species_abbreviation(speciesName)}_{groupName}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region.replace("|", "_")}.vcf.gz.csi'}
	options = {
		'cores': 1,
		'memory': f'{memory}g',
		'walltime': time
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	export _JAVA_OPTIONS="-Xmx{options['memory']}"

	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"

	[ -d {outputDirectory}/raw_vcf/{groupName}/tmp ] || mkdir -p {outputDirectory}/raw_vcf/{groupName}/tmp
	
	freebayes \\
		--fasta-reference {referenceGenomeFile} \\
		--use-best-n-alleles {bestNAlleles} \\
		--ploidy {ploidy} \\
		--region '{region}:{start}-{end}' \\
		--min-alternate-fraction {minAlternateFraction} \\
		--min-alternate-count {minAlternateCount} \\
		--pooled-discrete \\
		-b {' -b '.join(bamFiles)} \\
	| bcftools view \\
		--output-type z \\
		--output {outputDirectory}/raw_vcf/{groupName}/tmp/{species_abbreviation(speciesName)}_{groupName}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region.replace("|", "_")}.prog.vcf.gz \\
		--write-index \\
		-
	
	mv {outputDirectory}/raw_vcf/{groupName}/tmp/{species_abbreviation(speciesName)}_{groupName}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region.replace("|", "_")}.prog.vcf.gz {outputs['vcf']}
	mv {outputDirectory}/raw_vcf/{groupName}/tmp/{species_abbreviation(speciesName)}_{groupName}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region.replace("|", "_")}.prog.vcf.gz.csi {outputs['index']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def name_freebayes_partition_all(idx: str, target: AnonymousTarget) -> str:
	return f'freebayes_part_all_{os.path.basename(target.outputs["vcf"]).replace("-", "_").replace("|", "_")}'

def freebayes_partition_all(referenceGenomeFile: str, bamFiles: list, outputDirectory: str, speciesName: str, region: str, num: int, start: int, end: int, ploidy: int = 100, bestNAlleles: int = 3, minAlternateFraction: float | int = 0, minAlternateCount: int = 2, memory: int = 80, time: str = '48:00:00'):
	"""
	Template: Create VCF file for each partition in a large set of pooled alignments.
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'reference': referenceGenomeFile,
		   	  'bam': bamFiles}
	outputs = {'vcf': f'{outputDirectory}/raw_vcf/all/tmp/{species_abbreviation(speciesName)}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region.replace("|", "_")}.vcf.gz',
			   'index': f'{outputDirectory}/raw_vcf/all/tmp/{species_abbreviation(speciesName)}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region.replace("|", "_")}.vcf.gz.csi'}
	options = {
		'cores': 1,
		'memory': f'{memory}g',
		'walltime': time
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	export _JAVA_OPTIONS="-Xmx{options['memory']}"

	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"

	[ -d {outputDirectory}/raw_vcf/all/tmp ] || mkdir -p {outputDirectory}/raw_vcf/all/tmp
	
	freebayes \\
		--fasta-reference {referenceGenomeFile} \\
		--use-best-n-alleles {bestNAlleles} \\
		--ploidy {ploidy} \\
		--region '{region}:{start}-{end}' \\
		--min-alternate-fraction {minAlternateFraction} \\
		--min-alternate-count {minAlternateCount} \\
		--pooled-discrete \\
		-b {' -b '.join(bamFiles)} \\
	| bcftools view \\
		--output-type z \\
		--output {outputDirectory}/raw_vcf/all/tmp/{species_abbreviation(speciesName)}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region.replace("|", "_")}.prog.vcf.gz \\
		--write-index \\
		-
	
	mv {outputDirectory}/raw_vcf/all/tmp/{species_abbreviation(speciesName)}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region.replace("|", "_")}.prog.vcf.gz {outputs['vcf']}
	mv {outputDirectory}/raw_vcf/all/tmp/{species_abbreviation(speciesName)}.freebayes_n{bestNAlleles}_p{ploidy}_minaltfrc{minAlternateFraction}_minaltcnt{minAlternateCount}.{num}_{region.replace("|", "_")}.prog.vcf.gz.csi {outputs['index']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def concat(files: list, outputName: str, outputDirectory: str | None = None, compress: bool = False):
	"""
	Template: Name-sorts and concatenates files. Optionally compresses output using :script:`gzip`.
	
	Template I/O::
	
		inputs = {'files': files}
		outputs = {'concat_file': outputName.ext | outputName.ext.gzip}
	
	:param list files:
		List containing files to concatenate.
	:param str outputName:
		Desired name of output file, no extension.
	:param str outputDirectory:
		Path to output directory. Default is directory of 'files[0]'.
	:param bool compress:
		Bool indicating whether the output file should be compressed or not.
	"""
	if outputDirectory is None:
		outputDirectory = os.path.dirname(files[0])
	inputs = {'files': files}
	if compress:
		outputs = {'concat_file': f'{outputDirectory}/{outputName}{os.path.splitext(files[0])[1]}.gz'}
	else:
		outputs = {'concat_file': f'{outputDirectory}/{outputName}{os.path.splitext(files[0])[1]}'}
	options = {
		'cores': 2,
		'memory': '16g',
		'walltime': '24:00:00'
	}
	protect = outputs['concat_file']
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {outputDirectory}] || mkdir -p {outputDirectory}

	if [ {compress} == 'False' ]; then
		cat \\
			{' '.join(files)} \\
			> {outputDirectory}/{outputName}.prog{os.path.splitext(files[0])[1]}
		
		mv {outputDirectory}/{outputName}.prog{os.path.splitext(files[0])[1]} {outputs['concat_file']}
	else
		cat \\
			{' '.join(files)} \\
		| gzip \\
			-c \\
			- \\
			> {outputDirectory}/{outputName}.prog{os.path.splitext(files[0])[1]}.gz
		
		mv {outputDirectory}/{outputName}.prog{os.path.splitext(files[0])[1]}.gz {outputs['concat_file']}
	fi

	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, protect=protect, spec=spec)

def concat_vcf(files: list, outputName: str, outputDirectory: str| None = None, compress: bool = True):
	"""
	Template: Concatenates :format:`VCF` files. Optionally compresses output.
	
	Template I/O::
	
		inputs = {'files': files}
		outputs = {'concat_file': outputName.ext | outputName.ext.gzip}
	
	:param list files:
		List containing :format:`VCF` files to concatenate. Can already be gzipped.
	:param str outputName:
		Desired name of output file, no extension.
	:param str outputDirectory:
		Path to output directory. Default is directory of 'files[0]'.
	:param bool compress:
		Bool indicating whether the output file should be compressed or not.
	"""
	if not outputDirectory:
		outputDirectory = os.path.dirname(files[0])
	inputs = {'files': files}
	if compress:
		outputs = {'concat_file': f'{outputDirectory}/{outputName}.vcf.gz',
			 	   'index': f'{outputDirectory}/{outputName}.vcf.gz.csi'}
	else:
		outputs = {'concat_file': f'{outputDirectory}/{outputName}.vcf'}
	options = {
		'cores': 32,
		'memory': '40g',
		'walltime': '24:00:00'
	}
	protect = outputs['concat_file']
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {outputDirectory} ] || mkdir -p {outputDirectory}
	
	if [ {compress} == 'False' ]; then
		bcftools concat \\
			--threads {options['cores']} \\
			--output-type v \\
			--output {outputDirectory}/{outputName}.prog.vcf \\
			{' '.join(files)}

			mv {outputDirectory}/{outputName}.prog.vcf {outputs['concat_file']}
	else
		bcftools concat \\
			--threads {options['cores']} \\
			--output-type z \\
			--output {outputDirectory}/{outputName}.prog.vcf.gz \\
			{' '.join(files)}
		
		bcftools index \\
			--threads {options['cores']} \\
			{outputDirectory}/{outputName}.prog.vcf.gz

			mv {outputDirectory}/{outputName}.prog.vcf.gz {outputs['concat_file']}
			mv {outputDirectory}/{outputName}.prog.vcf.gz.csi {outputs['index']}
	fi
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, protect=protect, spec=spec)

def merge_and_norm_vcf(vcfFiles: list, referenceGenomeFile: str, outputName: str, outputDirectory: str):
	"""
	Template: template_description
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'vcfs': vcfFiles}
	outputs = {'vcf': f'{outputDirectory}/{outputName}.merged.norm.vcf.gz',
			   'index': f'{outputDirectory}/{outputName}.merged.norm.vcf.gz.csi'}
	options = {
		'cores': 30,
		'memory': '40g',
		'walltime': '12:00:00'
	}
	protect = [outputs['vcf'], outputs['index']]
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {outputDirectory} ] || mkdir -p {outputDirectory}
	
	bcftools merge \\
		--threads {options['cores']} \\
		--output-type v \\
		--missing-to-ref \\
		{' '.join(vcfFiles)} \\
	| bcftools norm \\
		--threads {options['cores']} \\
		--output-type z \\
		--output {outputDirectory}/{outputName}.merged.norm.prog.vcf.gz \\
		--fasta-ref {referenceGenomeFile} \\
		--write-index \\
		-
	
	mv {outputDirectory}/{outputName}.merged.norm.prog.vcf.gz {outputs['vcf']}
	mv {outputDirectory}/{outputName}.merged.norm.prog.vcf.gz.csi {outputs['index']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, protect=protect, spec=spec)

def merge_vcf(vcfFiles: list, outputName: str, outputDirectory: str):
	"""
	Template: template_description
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'vcfs': vcfFiles}
	outputs = {'vcf': f'{outputDirectory}/{outputName}.merged.vcf.gz',
			   'index': f'{outputDirectory}/{outputName}.merged.vcf.gz.csi'}
	options = {
		'cores': 30,
		'memory': '40g',
		'walltime': '12:00:00'
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {outputDirectory} ] || mkdir -p {outputDirectory}
	
	bcftools merge \\
		--threads {options['cores']} \\
		--output-type z \\
		--output {outputDirectory}/{outputName}.merged.prog.vcf.gz \\
		--missing-to-ref \\
		--write-index \\
		{' '.join(vcfFiles)}
	
	mv {outputDirectory}/{outputName}.merged.prog.vcf.gz {outputs['vcf']}
	mv {outputDirectory}/{outputName}.merged.prog.vcf.gz.csi {outputs['index']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def merge_vcf_no_duplicates(vcfFiles: list, outputName: str, outputDirectory: str):
	"""
	Template: template_description
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'vcfs': vcfFiles}
	outputs = {'vcf': f'{outputDirectory}/{outputName}.merged.vcf.gz',
			   'index': f'{outputDirectory}/{outputName}.merged.vcf.gz.csi',
			   'tsv': f'{outputDirectory}/{outputName}.merged.tsv'}
	protect=[outputs['vcf'], outputs['index']]
	options = {
		'cores': 30,
		'memory': '40g',
		'walltime': '12:00:00'
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {outputDirectory} ] || mkdir -p {outputDirectory}
	
	bcftools merge \\
		--threads {options['cores']} \\
		--output-type v \\
		--missing-to-ref \\
		{' '.join(vcfFiles)} \\
	| awk \\
		'BEGIN{{
			FS = OFS = "\\t"
		}}
		{{
			if ($0 ~ /^##/)
			{{
				print $0
				next
			}}
			if ($0 ~ /^#/)
			{{
				print "##awk_script=BEGIN{{FS = OFS = \"t\"}} {{if ($0 ~ /^##/) {{print $0; next}}; if ($0 ~ /^#/) {{print $0; next}}; if (previousPosition == -1) {{previousLine = $0; previousPosition = $2; next}}; if (previousPosition == $2) {{previousPosition = -1; next}}; if (previousPosition && previousPosition != $2 && previousPosition != -1) {{print previousLine}}; previousLine = $0; previousPosition = $2}} END{{if (previousPosition != -1) {{print $0}}}} " FILENAME
				print $0
				next
			}}
			if (previousPosition == -1)
			{{
				previousLine = $0
				previousPosition = $2
				next
			}}
			if (previousPosition == $2)
			{{
				previousPosition = -1
				duplicateCount += 1
				next
			}}
			if (previousPosition && previousPosition != $2 && previousPosition != -1)
			{{
				print previousLine
			}}
			previousLine = $0
			previousPosition = $2
		}}
		END{{
			if (previousPosition != -1)
			{{
				print $0
			}}
			print "{outputName}.merged.vcf.gz", duplicateCount > "{outputDirectory}/{outputName}.merged.prog.tsv"
		}}' \\
		- \\
	| bcftools view \\
		--threads {options['cores']} \\
		--output-type z \\
		--output {outputDirectory}/{outputName}.merged.prog.vcf.gz \\
		--write-index \\
		- \\
	
	mv {outputDirectory}/{outputName}.merged.prog.vcf.gz {outputs['vcf']}
	mv {outputDirectory}/{outputName}.merged.prog.vcf.gz.csi {outputs['index']}
	mv {outputDirectory}/{outputName}.merged.prog.tsv {outputs['tsv']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, protect=protect, options=options, spec=spec)

def norm_vcf(vcfFile: str, referenceGenomeFile: str, outputName: str, outputDirectory: str):
	"""
	Template: template_description
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'vcf': vcfFile}
	outputs = {'vcf': f'{outputDirectory}/{outputName}.norm.vcf.gz',
			   'index': f'{outputDirectory}/{outputName}.norm.vcf.gz.csi'}
	options = {
		'cores': 30,
		'memory': '40g',
		'walltime': '12:00:00'
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {outputDirectory} ] || mkdir -p {outputDirectory}
	
	bcftools norm \\
		--threads {options['cores']} \\
		--output-type z \\
		--output {outputDirectory}/{outputName}.norm.prog.vcf.gz \\
		--fasta-ref {referenceGenomeFile} \\
		--write-index \\
		{vcfFile}
	
	mv {outputDirectory}/{outputName}.norm.prog.vcf.gz {outputs['vcf']}
	mv {outputDirectory}/{outputName}.norm.prog.vcf.gz.csi {outputs['index']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def site_count_region(bamFiles: list, depthDistributionTsv: str, siteType: str, outputDirectory: str, outputName: str, bedFile: str | None = None):
	"""
	Template: template_description
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	if bedFile:
		inputs = {'bam': bamFiles,
			   	  'depth': depthDistributionTsv,
				  'bed': bedFile}
	else:
		inputs = {'bam': bamFiles,
			   	  'depth': depthDistributionTsv}
	outputs = {'sitetable': f'{outputDirectory}/sitetable/{outputName}.sitetable.{siteType}.tsv'}
	options = {
		'cores': 10,
		'memory': '40g',
		'walltime': '06:00:00'
	}
	populations = '\034'.join([os.path.basename(i).split(sep=".")[0] for i in bamFiles])
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {outputDirectory}/sitetable ] || mkdir -p {outputDirectory}/sitetable
	
	awk \\
		-v maxthreshold=$(awk \\
			'BEGIN{{
				FS = OFS = "\\t"
			}}
			{{
				if (NR == 2)
				{{
					print $7
					exit
				}}
			}}' \\
			{depthDistributionTsv}) \\
		-v minthreshold=$(awk \\
			'BEGIN{{
				FS = OFS = "\\t"
			}}
			{{
				if (NR == 2)
				{{
					print $6
					exit
				}}
			}}' \\
			{depthDistributionTsv}) \\
		'BEGIN{{
			FS = OFS = "\\t"
		}}
		{{
			if (FNR == NR)
			{{
				n = split($0, populations, "\\034")
				nextfile
			}}
			checksum = 0
			for (i = 3; i <= NF; i++)
			{{
				if ($i >= minthreshold && $i <= maxthreshold)
				{{
					checksum += 1
					thressites[populations[i - 2], "whole_genome"] += 1
					thressites[populations[i - 2], $1] += 1
				}}
			}}
			if (checksum == NF - 2)
			{{
				thressites["all", "whole_genome"] += 1
				thressites["all", $1] += 1
			}}
			allsites["all", "whole_genome"] += 1
			allsites["all", $1] += 1
		}}
		END{{
			print "stage", "identifier", "group", "region", "type", "site_count"
			for (i in allsites)
			{{
				split(i, allsitesarray, "\\034")
				print "0", "total", allsitesarray[1], allsitesarray[2], "{siteType}", allsites[i]
			}}
			for (i in thressites)
			{{
				split(i, thressitesarray, "\\034")
				print "1", "within_threshold", thressitesarray[1], thressitesarray[2], "{siteType}", thressites[i]
			}}
		}}' \\
		<(echo \\
			-e \\
			"{populations}") \\
		<(samtools depth \\
			--threads {options['cores']} \\
			{f'-b {bedFile}' if bedFile else ''} \\
			{' '.join(bamFiles)}) \\
	| awk \\
		'{{
			if (NR == 1)
			{{
				print $0
				next
			}}
			print $0 | "sort -k 1,1 -k 3,3 -k 4,4"
		}}' \\
		> {outputDirectory}/sitetable/{outputName}.sitetable.{siteType}.prog.tsv

	mv {outputDirectory}/sitetable/{outputName}.sitetable.{siteType}.prog.tsv {outputs['sitetable']}

	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def extract_softmasked_intervals(referenceGenomeFile: str, outputDirectory: str):
	"""
	Template: template_description
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'reference': referenceGenomeFile}
	outputs = {'bed': f'{outputDirectory}/annotation/{os.path.splitext(os.path.splitext(os.path.basename(referenceGenomeFile))[0])[0] if referenceGenomeFile.endswith('.gz') else os.path.splitext(os.path.basename(referenceGenomeFile))[0]}.repeats.bed'}
	options = {
		'cores': 1,
		'memory': '10g',
		'walltime': '02:00:00'
	}
	protect = {outputs['bed']}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {outputDirectory}/annotation ] || mkdir -p {outputDirectory}/annotation
	
	bedtools merge \\
		-i <(awk \\
			'function maskedinterval(string)
			{{
				result = match(string, /[a-z]+/, matcharray)
				if (result != 0)
				{{
					start = pos + RSTART - 1
					end = start + RLENGTH
					print seqname, start, end
					sub(matcharray[0], toupper(matcharray[0]), string)
 					maskedinterval(string)
				}}
			}}
			BEGIN{{
				FS = "\\t"
				OFS = "\\t"
			}}
			{{
				if ($0 ~ /^>/)
				{{
					split($1, seqnamearray, " ")
					seqname = substr(seqnamearray[1], 2)
					pos = 0
					next
				}}
				maskedinterval($0)
				pos += length($0)
			}}' \\
			{'<(zcat' + referenceGenomeFile + ')' if referenceGenomeFile.endswith('.gz') else referenceGenomeFile}) \\
		> {outputDirectory}/annotation/{os.path.splitext(os.path.splitext(os.path.basename(referenceGenomeFile))[0])[0] if referenceGenomeFile.endswith('.gz') else os.path.splitext(os.path.basename(referenceGenomeFile))[0]}.repeats.prog.bed
	
	mv {outputDirectory}/annotation/{os.path.splitext(os.path.splitext(os.path.basename(referenceGenomeFile))[0])[0] if referenceGenomeFile.endswith('.gz') else os.path.splitext(os.path.basename(referenceGenomeFile))[0]}.repeats.prog.bed {outputs['bed']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, protect=protect, spec=spec)

def bed_exclude_overlap(mainBedFile: str, subtractionBedFile: str, outputDirectory: str, speciesName: str):
	"""
	Template: template_description
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'main': mainBedFile,
		   	  'sub': subtractionBedFile}
	outputs = {'bed': f'{outputDirectory}/sitetable/{species_abbreviation(speciesName)}.intergenic_excl_repeats.bed'}
	options = {
		'cores': 1,
		'memory': '10g',
		'walltime': '01:00:00'
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {outputDirectory}/sitetable ] || mkdir -p {outputDirectory}/sitetable
	
	bedtools subtract \\
		-a {mainBedFile} \\
		-b {subtractionBedFile} \\
		> {outputDirectory}/sitetable/{species_abbreviation(speciesName)}.intergenic_excl_repeats.prog.bed
	
	mv {outputDirectory}/sitetable/{species_abbreviation(speciesName)}.intergenic_excl_repeats.prog.bed {outputs['bed']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def filter_vcf(vcfFile: str, depthDistributionTsv: str, outputDirectory: str, groupStatus: str):
	"""
	Template: template_description
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'vcf': vcfFile,
		   	  'depth': depthDistributionTsv}
	outputs = {'vcf': f'{outputDirectory}/{os.path.splitext(os.path.splitext(os.path.basename(vcfFile))[0])[0] if vcfFile.endswith(".gz") else os.path.splitext(os.path.basename(vcfFile))[0]}.bcftoolsfilter_AF0_SnpGap5_typesnps_biallelic_DPdynamic_AO1.{'ingroup' if groupStatus == 'i' else 'outgroup'}.vcf.gz',
			   'index': f'{outputDirectory}/{os.path.splitext(os.path.splitext(os.path.basename(vcfFile))[0])[0] if vcfFile.endswith(".gz") else os.path.splitext(os.path.basename(vcfFile))[0]}.bcftoolsfilter_AF0_SnpGap5_typesnps_biallelic_DPdynamic_AO1.{'ingroup' if groupStatus == 'i' else 'outgroup'}.vcf.gz.csi',
			   'sitetable': f'{outputDirectory}/sitetable/{os.path.basename(vcfFile).split('.')[0]}.{'ingroup' if groupStatus == 'i' else 'outgroup'}.sitetable.variable.tsv'}
	options = {
		'cores': 18,
		'memory': '30g',
		'walltime': '24:00:00'
	}
	protect = [outputs['vcf'], outputs['index'], outputs['sitetable']]
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {outputDirectory}/sitetable ] || mkdir -p {outputDirectory}/sitetable

	variablesitecount() {{
		awk \\
			-v first="$1" \\
			-v stage="$2" \\
			-v identifier="$3" \\
			'BEGIN{{
				FS = OFS = "\\t"
			}}
			{{
				if ($0 ~ /^##/)
				{{
					next
				}}
				if ($0 ~ /^#CHROM/)
				{{
					for (i = 10; i <= NF; i++)
					{{
						populations[i] = $i
					}}
					next
				}}
				for (i = 10; i <= NF; i++)
				{{
					split($i, genotypearray, ":")
					if (genotypearray[1] !~ /^0\\/.*0$/)
					{{
						npopulationvariants[populations[i], "whole_genome"] += 1
						npopulationvariants[populations[i], $1] += 1
					}}
				}}
				ntotalvariants["whole_genome"] += 1
				ntotalvariants[$1] += 1
			}}
			END{{
				if (first == 1)
				{{
					print "stage", "identifier", "group", "region", "type", "site_count"
				}}
				for (i in ntotalvariants)
				{{
					print stage, identifier, "all", i, "variable", ntotalvariants[i]
				}}
				for (i in npopulationvariants)
				{{
					split(i, popregion, "\\034")
					print stage, identifier, popregion[1], popregion[2], "variable", npopulationvariants[i]
				}}
			}}'
	}}
	
	maxdepth=$(awk \\
		'BEGIN{{
			FS = OFS = "\\t"
		}}
		{{
			if (NR == 2)
			{{
				print $8
				exit
			}}
		}}' \\
		{depthDistributionTsv})
	
	mindepth=$(awk \\
		'BEGIN{{
			FS = OFS = "\\t"
		}}
		{{
			if (NR == 2)
			{{
				print $7
				exit
			}}
		}}' \\
		{depthDistributionTsv})
	
	bcftools view \\
		--threads {options['cores']} \\
		--output-type v \\
		{vcfFile} \\
	| tee \\
		>(variablesitecount \\
			1 \\
			0 \\
			"total" \\
			> {outputDirectory}/sitetable/{os.path.basename(vcfFile).split('.')[0]}.{'ingroup' if groupStatus == 'i' else 'outgroup'}.sitetable.variable.unsorted.tsv) \\
	| awk \\
		'BEGIN{{
			FS = OFS = "\\t"
		}}
		{{
			if ($0 ~ /^##/)
			{{
				print $0
				next
			}}
			if ($0 ~ /^#/)
			{{
				print "##awk_script=BEGIN{{FS = OFS = \"t\"}} {{if ($0 ~ /^##/) {{print $0; next}}; if ($0 ~ /^#/) {{print $0; next}}; if (previousPosition == -1) {{previousLine = $0; previousPosition = $2; next}}; if (previousPosition == $2) {{previousPosition = -1; next}}; if (previousPosition && previousPosition != $2 && previousPosition != -1) {{print previousLine}}; previousLine = $0; previousPosition = $2}} END{{if (previousPosition != -1) {{print $0}}}} " FILENAME
				print $0
				next
			}}
			if (previousPosition == -1)
			{{
				previousLine = $0
				previousPosition = $2
				next
			}}
			if (previousPosition == $2)
			{{
				previousPosition = -1
				duplicateCount += 1
				next
			}}
			if (previousPosition && previousPosition != $2 && previousPosition != -1)
			{{
				print previousLine
			}}
			previousLine = $0
			previousPosition = $2
		}}
		END{{
			if (previousPosition != -1)
			{{
				print $0
			}}
			print "Duplicate position pairs: ", duplicateCount > "dev/stderr"
		}}' \\
		- \\
	| tee \\
		>(variablesitecount \\
			0 \\
			2 \\
			"duplicate_positions" \\
			>> {outputDirectory}/sitetable/{os.path.basename(vcfFile).split('.')[0]}.{'ingroup' if groupStatus == 'i' else 'outgroup'}.sitetable.variable.unsorted.tsv) \\
	| bcftools view \\
		--threads {options['cores']} \\
		--include 'INFO/AF > 0' \\
		--output-type v \\
		- \\
	| tee \\
		>(variablesitecount \\
			0 \\
			3 \\
			"AF>0" \\
			>> {outputDirectory}/sitetable/{os.path.basename(vcfFile).split('.')[0]}.{'ingroup' if groupStatus == 'i' else 'outgroup'}.sitetable.variable.unsorted.tsv) \\
	| bcftools filter \\
		--threads {options['cores']} \\
		--SnpGap 5:indel \\
		--output-type v \\
		- \\
	| tee \\
		>(variablesitecount \\
			0 \\
			4 \\
			"indel_proximity" \\
			>> {outputDirectory}/sitetable/{os.path.basename(vcfFile).split('.')[0]}.{'ingroup' if groupStatus == 'i' else 'outgroup'}.sitetable.variable.unsorted.tsv) \\
	| bcftools view \\
		--threads {options['cores']} \\
		--types snps \\
		--output-type v \\
		- \\
	| tee \\
		>(variablesitecount \\
			0 \\
			5 \\
			"snps_only" \\
			>> {outputDirectory}/sitetable/{os.path.basename(vcfFile).split('.')[0]}.{'ingroup' if groupStatus == 'i' else 'outgroup'}.sitetable.variable.unsorted.tsv) \\
	| bcftools view \\
		--threads {options['cores']} \\
		--max-alleles 2 \\
		--output-type v \\
		- \\
	| tee \\
		>(variablesitecount \\
			0 \\
			6 \\
			"biallelic_only" \\
			>> {outputDirectory}/sitetable/{os.path.basename(vcfFile).split('.')[0]}.{'ingroup' if groupStatus == 'i' else 'outgroup'}.sitetable.variable.unsorted.tsv) \\
	| bcftools view \\
		--threads {options['cores']} \\
		--include "FMT/DP>=$mindepth & FMT/DP<=$maxdepth" \\
		--output-type v \\
		- \\
	| tee \\
		>(variablesitecount \\
			0 \\
			7 \\
			"depth_thresholds" \\
			>> {outputDirectory}/sitetable/{os.path.basename(vcfFile).split('.')[0]}.{'ingroup' if groupStatus == 'i' else 'outgroup'}.sitetable.variable.unsorted.tsv) \\
	| bcftools view \\
		--threads {options['cores']} \\
		--include 'FMT/AO > 1' \\
		--output-type v \\
		- \\
	| tee \\
		>(variablesitecount \\
			0 \\
			8 \\
			"AO>1" \\
			>> {outputDirectory}/sitetable/{os.path.basename(vcfFile).split('.')[0]}.{'ingroup' if groupStatus == 'i' else 'outgroup'}.sitetable.variable.unsorted.tsv) \\
	| bcftools view \\
		--threads {options['cores']} \\
		--output-type z \\
		--output {outputDirectory}/{os.path.splitext(os.path.splitext(os.path.basename(vcfFile))[0])[0] if vcfFile.endswith(".gz") else os.path.splitext(os.path.basename(vcfFile))[0]}.bcftoolsfilter_AF0_SnpGap5_typesnps_biallelic_DPdynamic_AO1.{'ingroup' if groupStatus == 'i' else 'outgroup'}.prog.vcf.gz \\
		--write-index \\
		-
	
	awk \\
		'BEGIN{{
			FS = OFS = "\\t"
		}}
		{{
			if (NR == 1)
			{{
				print $0
				next
			}}
			print $0 | "sort -k 1,1 -k 3,3 -k 4,4"
		}}' \\
		{outputDirectory}/sitetable/{os.path.basename(vcfFile).split('.')[0]}.{'ingroup' if groupStatus == 'i' else 'outgroup'}.sitetable.variable.unsorted.tsv \\
		> {outputDirectory}/sitetable/{os.path.basename(vcfFile).split('.')[0]}.{'ingroup' if groupStatus == 'i' else 'outgroup'}.sitetable.variable.prog.tsv
		
	mv {outputDirectory}/{os.path.splitext(os.path.splitext(os.path.basename(vcfFile))[0])[0] if vcfFile.endswith(".gz") else os.path.splitext(os.path.basename(vcfFile))[0]}.bcftoolsfilter_AF0_SnpGap5_typesnps_biallelic_DPdynamic_AO1.{'ingroup' if groupStatus == 'i' else 'outgroup'}.prog.vcf.gz {outputs['vcf']}
	mv {outputDirectory}/{os.path.splitext(os.path.splitext(os.path.basename(vcfFile))[0])[0] if vcfFile.endswith(".gz") else os.path.splitext(os.path.basename(vcfFile))[0]}.bcftoolsfilter_AF0_SnpGap5_typesnps_biallelic_DPdynamic_AO1.{'ingroup' if groupStatus == 'i' else 'outgroup'}.prog.vcf.gz.csi {outputs['index']}
	mv {outputDirectory}/sitetable/{os.path.basename(vcfFile).split('.')[0]}.{'ingroup' if groupStatus == 'i' else 'outgroup'}.sitetable.variable.prog.tsv {outputs['sitetable']}
	rm {outputDirectory}/sitetable/{os.path.basename(vcfFile).split('.')[0]}.{'ingroup' if groupStatus == 'i' else 'outgroup'}.sitetable.variable.unsorted.tsv
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, protect=protect, spec=spec)

def merge_site_tables(siteTables: list, outputName: str, outputDirectory: str):
	"""
	Template: template_description
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'tables': siteTables}
	outputs = {'sitetable': f'{outputDirectory}/sitetable/{outputName}.sitetable.tsv'}
	options = {
		'cores': 1,
		'memory': '10g',
		'walltime': '02:00:00'
	}
	protect = [outputs['sitetable']]
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {outputDirectory}/sitetable ] || mkdir -p {outputDirectory}/sitetable
	
	awk \\
		'BEGIN{{
			FS = OFS = "\\t"
		}}
		{{
			if (FNR == 1)
			{{
				if (FNR == NR)
				{{
					print $0
				}}
				next
			}}
			print $0 | "sort -k 1,1 -k 3,3 -k 4,4"
		}}' \\
		{' '.join(siteTables)} \\
		> {outputDirectory}/sitetable/{outputName}.sitetable.prog.tsv
	
	mv {outputDirectory}/sitetable/{outputName}.sitetable.prog.tsv {outputs['sitetable']}

	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, protect=protect, spec=spec)

def singleton_proportion(outputDirectory: str, speciesName: str):
	"""
	Template: template_description
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {}
	outputs = {}
	options = {
		'cores': 10,
		'memory': '40g',
		'walltime': '04:00:00'
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {outputDirectory} ] || mkdir -p {outputDirectory}
	
	awk \\
		-v minthreshold="$min" \\
		-v maxthreshold="$max" \\
		'BEGIN{{
			FS = OFS = "\\t"
			for (i = minthreshold; i <= maxthreshold; i += 10)
			{{
				bincountsites[i] = 0
				bincountsingletons[i] = 0
			}}
		}}
		{{
			if (FNR == NR)
			{{
				if ($3 >= minthreshold && $3 <= maxthreshold)
				{{
					bincountsites[10 * int($3 / 10)] += 1
				}}
				next
			}}
			if ($1 >= minthreshold && $1 <= maxthreshold && ($2 ~ /0\\/1$/))
			{{
				bincountsingletons[10 * int($1 / 10)] += 1
				
			}}
		}}
		END{{
			print "coverage_bin", "n_sites", "n_singletons", "singleton_proportion"
			for (i in bincountsites)
			{{
				print i "-" i + 9, bincountsites[i], bincountsingletons[i], bincountsingletons[i] / bincountsites[i]
			}}
		}}' \\
		<(samtools depth \\
			--threads {options['cores']} \\
			"$i"*.bam) \\
		<(bcftools query \\
			-f '%INFO/DP\\t[%GT]\\n' \\
			"$i"*.vcf.gz) \\
		> "$i".bincounts.tsv
	
	mv
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)
