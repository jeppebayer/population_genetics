#!/bin/env python3
from gwf import AnonymousTarget
import os, glob

########################## Functions ##########################

def species_abbreviation(species_name: str) -> str:
	"""Creates species abbreviation from species name.

	:param str species_name:
		Species name written as *genus* *species*"""
	genus, species = species_name.replace(' ', '_').split('_')
	genus = genus[0].upper() + genus[1:3]
	species = species[0].upper() + species[1:3]
	return genus + species

def parse_fasta(fasta_file: str):
	"""
	Parses :format:`FASTA` file returning all sequence names and lengths paired in a list of dictionaries.
	
	::
	
		return [{'sequence_name': str, 'sequence_length': int}, ...]
	
	:param str fasta_file:
		Sequence file in :format:`FASTA` format.
	"""
	fasta_list = []
	seq_name = None
	length = 0
	with open(fasta_file, 'r') as fasta:
		for entry in fasta:
			entry = entry.strip()
			if entry.startswith(">"):
				if seq_name:
					fasta_list.append({'sequence_name': seq_name, 'sequence_length': length})
					length = 0
				entry = entry.split(" ", 1)
				seq_name = entry[0][1:]
			else:
				length += len(entry)
		fasta_list.append({'sequence_name': seq_name, 'sequence_length': length})
	return fasta_list

def padding_calculator(parse_fasta: list, size: int = 500000):
	"""
	Calculates proper 0 padding for numbers in **partition_chrom**.

	:param list parse_fasta:
		List of dictionaries produced by **parse_fasta**.
	:param int size:
		Size of partitions. Default 500kb.
	"""
	num = 1
	for chrom in parse_fasta:
		whole_chunks = chrom['sequence_length'] // size
		num += (whole_chunks + 1)
	return len(str(num))

def partition_chrom(parse_fasta: list, size: int = 500000, npad: int = 5):
	"""
	Partitions :format:`FASTA` file parsed with **parse_fasta**.
	
	Uses the list of dictionaries from **parse_fasta** to creates a list of dictionaries
	containing partition number, sequence name, start and end postion (0 based).
	By default the partition size is 500kbs.
	
	::
	
		return [{'num': int, 'region': str, 'start': int, 'end': int}, ...]
	
	:param list parse_fasta:
		List of dictionaries produced by **parse_fasta**.
	:param int size:
		Size of partitions. Default 500kb.
	"""
	chrom_partition = []
	num = 1
	for chrom in parse_fasta:
		whole_chunks = chrom['sequence_length'] // size
		partial_chunk = chrom['sequence_length'] - whole_chunks * size
		start = 0
		for chunk in range(whole_chunks):
			end = start + size
			chrom_partition.append({'num': f'{num:0{npad}}', 'region': chrom['sequence_name'], 'start': start, 'end': end})
			start = end
			num += 1
		chrom_partition.append({'num': f'{num:0{npad}}', 'region': chrom['sequence_name'], 'start': start, 'end': start + partial_chunk})
		num += 1
	return chrom_partition

def mpileup_partitions_filelist(partitions: list, top_dir: str, species_name: str, npad: int = 5):
	"""
	Generates list of dictionaries containing names of contigs and filenames of :format:`mpileup`-parts per contig based on **partition_chrom** output.

	Uses the list of dictionaries generated by **partition_chrom** to create a list of dictionaries where each dictionary contains the name of a contig
	and the names of output files created **mpileup_part** using those same partitions.

	::

		return [{'contig': str, 'mpileup_files': list}, ...]
	
	:param list partitions:
		List of dictionaries produced by **partition_chrom**.
	:param str top_dir:
		Top most level of current working directory.
	:param str species_name:
		Name of species currently being worked on.
	"""
	mpileup_filelists = []
	contig_name = None
	part_num = 0
	for partition in partitions:
		part_num += 1
		if partition['region'] != contig_name:
			if contig_name:
				mpileup_filelists.append({'contig': contig_name, 'mpileup_files': [f'{top_dir}/tmp/mpileup/{species_abbreviation(species_name)}_{num:0{npad}}_{contig_name}.mpileup' for num in range(start, part_num)]})
			start = part_num
			contig_name = partition['region']
	mpileup_filelists.append({'contig': contig_name, 'mpileup_files': [f'{top_dir}/tmp/mpileup/{species_abbreviation(species_name)}_{num:0{npad}}_{contig_name}.mpileup' for num in range(start, part_num + 1)]})
	return mpileup_filelists

########################## Freebayes ##########################

def name_freebayes_chrom(idx: str, target: AnonymousTarget) -> str:
	return f'{os.path.basename(target.outputs["vcf"].replace("-", "_"))}'

# def freebayes_chrom(reference_genome_file: str, bam_file_list: list, output_directory: str, species_name: str, region: str, num: int, start: int, end: int, ploidy: int = 100, best_n_alleles: int = 3, min_alternate_fraction: float | int = 0, min_alternate_count: int = 2):
# 	"""
# 	Template: Create VCF file for each 'chromosome' in pooled alignment.
	
# 	Template I/O::
	
# 		inputs = {}
# 		outputs = {}
	
# 	:param
# 	"""
# 	bam_file_string = ' -b '.join(bam_file_list)
# 	inputs = {'reference': reference_genome_file,
# 		   	  'bam': bam_file_list}
# 	outputs = {'vcf': f'{output_directory}/freebayes_vcf/tmp/{species_abbreviation(species_name)}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.vcf'}
# 	options = {
# 		'cores': 1,
# 		'memory': '100g',
# 		'walltime': '36:00:00'
# 	}
# 	spec = f"""
# 	# Sources environment
# 	if [ "$USER" == "jepe" ]; then
# 		source /home/"$USER"/.bashrc
# 		source activate vcf
# 	fi
	
# 	export _JAVA_OPTIONS="-Xmx{options['memory']}"

# 	echo "START: $(date)"
# 	echo "JobID: $SLURM_JOBID"

# 	[ -d {output_directory}/freebayes_vcf/tmp ] || mkdir -p {output_directory}/freebayes_vcf/tmp
	
# 	freebayes \
# 		-f {reference_genome_file} \
# 		-n {best_n_alleles} \
# 		-p {ploidy} \
# 		-r {region}:{start}-{end} \
# 		--min-alternate-fraction {min_alternate_fraction} \
# 		--min-alternate-count {min_alternate_count} \
# 		--pooled-discrete \
#         -b {bam_file_string} \
# 	| bcftools filter \
# 		-e 'INFO/TYPE~"del" || INFO/TYPE~"ins"' \
# 		-O v \
# 		- \
# 		> {output_directory}/freebayes_vcf/tmp/{species_abbreviation(species_name)}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.prog.vcf
	
# 	mv {output_directory}/freebayes_vcf/tmp/{species_abbreviation(species_name)}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.prog.vcf {outputs['vcf']}
	
# 	echo "END: $(date)"
# 	echo "$(jobinfo "$SLURM_JOBID")"
# 	"""
# 	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def freebayes_chrom(reference_genome_file: str, bam_file_list: list, output_directory: str, species_name: str, region: str, num: int, start: int, end: int, ploidy: int = 100, best_n_alleles: int = 3, min_alternate_fraction: float | int = 0, min_alternate_count: int = 2):
	"""
	Template: Create VCF file for each 'chromosome' in pooled alignment.
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	bam_file_string = ' -b '.join(bam_file_list)
	inputs = {'reference': reference_genome_file,
		   	  'bam': bam_file_list}
	outputs = {'vcf': f'{output_directory}/freebayes_vcf/tmp/{species_abbreviation(species_name)}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.vcf'}
	options = {
		'cores': 1,
		'memory': '80g',
		'walltime': '60:00:00'
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	export _JAVA_OPTIONS="-Xmx{options['memory']}"

	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"

	[ -d {output_directory}/freebayes_vcf/tmp ] || mkdir -p {output_directory}/freebayes_vcf/tmp
	
	freebayes \
		-f {reference_genome_file} \
		-n {best_n_alleles} \
		-p {ploidy} \
		-r {region}:{start}-{end} \
		--min-alternate-fraction {min_alternate_fraction} \
		--min-alternate-count {min_alternate_count} \
		--pooled-discrete \
		-b {bam_file_string} \
		> {output_directory}/freebayes_vcf/tmp/{species_abbreviation(species_name)}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.prog.vcf
	
	mv {output_directory}/freebayes_vcf/tmp/{species_abbreviation(species_name)}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.prog.vcf {outputs['vcf']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def index_reference_genome(reference_genome_file: str, output_directory: str):
	"""
	Template: Index reference genome with :script:`bwa index` and :script:`samtools faidx`.
	
	Template I/O::
	
		inputs = {'reference': reference_genome_file}
		outputs = {'symlink': *, 'bwa': [*.amb, *.ann, *.pac, *.bwt, *.sa], 'fai': *.fai}
	
	:param str reference_genome_file:
		Path to reference genome.
	:param str output_directory:
		Path to output directory.
	"""
	inputs = {'reference': reference_genome_file}
	outputs = {'symlink': f'{output_directory}/reference/{os.path.basename(reference_genome_file)}',
			   'bwa': [f'{output_directory}/reference/{os.path.basename(reference_genome_file)}.amb',
					   f'{output_directory}/reference/{os.path.basename(reference_genome_file)}.ann',
					   f'{output_directory}/reference/{os.path.basename(reference_genome_file)}.pac',
					   f'{output_directory}/reference/{os.path.basename(reference_genome_file)}.bwt',
					   f'{output_directory}/reference/{os.path.basename(reference_genome_file)}.sa'],
			   'fai': f'{output_directory}/reference/{os.path.basename(reference_genome_file)}.fai'}
	protect = [outputs['symlink'], outputs['bwa'][0], outputs['bwa'][1], outputs['bwa'][2], outputs['bwa'][3], outputs['bwa'][4], outputs['fai']]
	options = {
		'cores': 1,
		'memory': '10g',
		'walltime': '04:00:00'
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {output_directory}/reference ] || mkdir -p {output_directory}/reference
	[ -e {output_directory}/reference/{os.path.basename(reference_genome_file)} ] && rm -f {output_directory}/reference/{os.path.basename(reference_genome_file)}
	ln -s {reference_genome_file} {output_directory}/reference/{os.path.basename(reference_genome_file)}
	
	bwa index \
		-p {output_directory}/reference/{os.path.basename(reference_genome_file)} \
		{output_directory}/reference/{os.path.basename(reference_genome_file)}
	
	samtools faidx \
		-o {output_directory}/reference/{os.path.basename(reference_genome_file)}.prog.fai \
		{output_directory}/reference/{os.path.basename(reference_genome_file)}
	
	mv {output_directory}/reference/{os.path.basename(reference_genome_file)}.prog.fai {outputs['fai']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, protect=protect, options=options, spec=spec)

def depth_distribution(bam_files: list, output_directory: str, species_name: str):
	"""
	Template: Calculate the per site depth distribution across all populations using :script:`samtools depth`.
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'bam': bam_files}
	outputs = {'depth': f'{output_directory}/depth_distribution/{species_abbreviation(species_name)}.depth'}
	options = {
		'cores': 30,
		'memory': '20g',
		'walltime': '12:00:00'
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {output_directory}/depth_distribution ] || mkdir -p {output_directory}/depth_distribution
	
	samtools depth \
		--threads {options['cores']} \
		-o {output_directory}/depth_distribution/{species_abbreviation(species_name)}.prog.depth \
		{' '.join(bam_files)}
	
	mv {output_directory}/depth_distribution/{species_abbreviation(species_name)}.prog.depth {outputs['depth']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def depth_distribution_plot(depth_distribution_file: str, min_coverage_threshold: int, plot_depth_distribution: str = f'{os.path.dirname(os.path.realpath(__file__))}/software/depthdistribution.py'):
	"""
	Template: template_description
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'depth': depth_distribution_file}
	outputs = {'plot': f'{depth_distribution_file}.png',
			   'tsv': f'{depth_distribution_file}.tsv'}
	options = {
		'cores': 1,
		'memory': '400g',
		'walltime': '04:00:00'
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	python {plot_depth_distribution} \
		{min_coverage_threshold} \
		{depth_distribution_file}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def shared_sites_within_threshold_bed(depth_distribution_file: str, depth_distribution_tsv: str, output_directory: str, species_name: str):
	"""
	Template: template_description
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'depth_file': depth_distribution_file,
		   	  'depth_tsv': depth_distribution_tsv}
	outputs = {'bed': f'{output_directory}/depth_distribution/{species_abbreviation(species_name)}.depththreshold.bed'}
	options = {
		'cores': 1,
		'memory': '10g',
		'walltime': '02:00:00'
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {output_directory}/depth_distribution ] || mkdir -p {output_directory}/depth_distribution
	
	bedtools merge \
		-i <(awk \
		-v maxthreshold = $(awk 'BEGIN{{FS = OFS = "\\t"}} {{if (NR == 2) {{print $7; exit}}}}' {depth_distribution_tsv}) \
		-v minthreshold = $(awk 'BEGIN{{FS = OFS = "\\t"}} {{if (NR == 2) {{print $6; exit}}}}' {depth_distribution_tsv}) \
		'BEGIN{{FS = OFS = "\\t"}}
		checksum = 0
		{{
		for (i = 1; i <= NF, i++)
			{{
			if ($i >= minthreshold && $i <= maxthreshold)
				{{checksum += 1}}
			}}
		if (checksum == NF)
			{{print $1, $2 - 1, $2}}
		}}' \
		{depth_distribution_file}) \
		> {output_directory}/depth_distribution/{species_abbreviation(species_name)}.depththreshold.prog.bed
	
	mv {output_directory}/depth_distribution/{species_abbreviation(species_name)}.depththreshold.prog.bed {outputs['bed']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def name_freebayes_partition_single(idx: str, target: AnonymousTarget) -> str:
	return f'freebayes_part_single_{os.path.basename(target.outputs["vcf"]).replace("-", "_").replace("|", "_")}'

def freebayes_partition_single(reference_genome_file: str, bam_file: str, output_directory: str, group_name: str, sample_name: str, region: str, num: int, start: int, end: int, ploidy: int = 100, best_n_alleles: int = 3, min_alternate_fraction: float | int = 0, min_alternate_count: int = 2):
	"""
	Template: Create VCF file for each partition in a single pooled alignment.
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'reference': reference_genome_file,
		   	  'bam': bam_file}
	outputs = {'vcf': f'{output_directory}/raw_vcf/{group_name}/{sample_name}/tmp/{sample_name}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.vcf.gz',
			   'index': f'{output_directory}/raw_vcf/{group_name}/{sample_name}/tmp/{sample_name}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.vcf.gz.csi'}
	options = {
		'cores': 1,
		'memory': '80g',
		'walltime': '96:00:00'
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	export _JAVA_OPTIONS="-Xmx{options['memory']}"

	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"

	[ -d {output_directory}/raw_vcf/{group_name}/{sample_name}/tmp ] || mkdir -p {output_directory}/raw_vcf/{group_name}/{sample_name}/tmp
	
	freebayes \
		--fasta-reference {reference_genome_file} \
		--use-best-n-alleles {best_n_alleles} \
		--ploidy {ploidy} \
		--region {region}:{start}-{end} \
		--min-alternate-fraction {min_alternate_fraction} \
		--min-alternate-count {min_alternate_count} \
		--pooled-discrete \
		-b {bam_file} \
	| bcftools view \
		--output-type z \
		--output {output_directory}/raw_vcf/{group_name}/{sample_name}/tmp/{sample_name}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.prog.vcf.gz \
		--write-index \
		-
	
	mv {output_directory}/raw_vcf/{group_name}/{sample_name}/tmp/{sample_name}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.prog.vcf.gz {outputs['vcf']}
	mv {output_directory}/raw_vcf/{group_name}/{sample_name}/tmp/{sample_name}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.prog.vcf.gz.csi {outputs['index']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def name_freebayes_partition_group(idx: str, target: AnonymousTarget) -> str:
	return f'freebayes_part_group_{os.path.basename(target.outputs["vcf"]).replace("-", "_").replace("|", "_")}'

def freebayes_partition_group(reference_genome_file: str, bam_files: list, output_directory: str, species_name: str, group_name: str, region: str, num: int, start: int, end: int, ploidy: int = 100, best_n_alleles: int = 3, min_alternate_fraction: float | int = 0, min_alternate_count: int = 2):
	"""
	Template: Create VCF file for each partition in a group of pooled alignments.
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'reference': reference_genome_file,
		   	  'bam': bam_files}
	outputs = {'vcf': f'{output_directory}/raw_vcf/{group_name}/tmp/{species_abbreviation(species_name)}_{group_name}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.vcf.gz',
			   'index': f'{output_directory}/raw_vcf/{group_name}/tmp/{species_abbreviation(species_name)}_{group_name}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.vcf.gz.csi'}
	options = {
		'cores': 1,
		'memory': '100g',
		'walltime': '96:00:00'
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	export _JAVA_OPTIONS="-Xmx{options['memory']}"

	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"

	[ -d {output_directory}/raw_vcf/{group_name}/tmp ] || mkdir -p {output_directory}/raw_vcf/{group_name}/tmp
	
	freebayes \
		--fasta-reference {reference_genome_file} \
		--use-best-n-alleles {best_n_alleles} \
		--ploidy {ploidy} \
		--region {region}:{start}-{end} \
		--min-alternate-fraction {min_alternate_fraction} \
		--min-alternate-count {min_alternate_count} \
		--pooled-discrete \
		-b {' -b '.join(bam_files)} \
	| bcftools view \
		--output-type z \
		--output {output_directory}/raw_vcf/{group_name}/tmp/{species_abbreviation(species_name)}_{group_name}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.prog.vcf.gz \
		--write-index \
		-
	
	mv {output_directory}/raw_vcf/{group_name}/tmp/{species_abbreviation(species_name)}_{group_name}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.prog.vcf.gz {outputs['vcf']}
	mv {output_directory}/raw_vcf/{group_name}/tmp/{species_abbreviation(species_name)}_{group_name}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.prog.vcf.gz.csi {outputs['index']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def name_freebayes_partition_all(idx: str, target: AnonymousTarget) -> str:
	return f'freebayes_part_all_{os.path.basename(target.outputs["vcf"]).replace("-", "_").replace("|", "_")}'

def freebayes_partition_all(reference_genome_file: str, bam_files: list, output_directory: str, species_name: str, region: str, num: int, start: int, end: int, ploidy: int = 100, best_n_alleles: int = 3, min_alternate_fraction: float | int = 0, min_alternate_count: int = 2):
	"""
	Template: Create VCF file for each partition in a large set of pooled alignments.
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'reference': reference_genome_file,
		   	  'bam': bam_files}
	outputs = {'vcf': f'{output_directory}/raw_vcf/all/tmp/{species_abbreviation(species_name)}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.vcf.gz',
			   'index': f'{output_directory}/raw_vcf/all/tmp/{species_abbreviation(species_name)}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.vcf.gz.csi'}
	options = {
		'cores': 1,
		'memory': '100g',
		'walltime': '96:00:00'
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	export _JAVA_OPTIONS="-Xmx{options['memory']}"

	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"

	[ -d {output_directory}/raw_vcf/all/tmp ] || mkdir -p {output_directory}/raw_vcf/all/tmp
	
	freebayes \
		--fasta-reference {reference_genome_file} \
		--use-best-n-alleles {best_n_alleles} \
		--ploidy {ploidy} \
		--region {region}:{start}-{end} \
		--min-alternate-fraction {min_alternate_fraction} \
		--min-alternate-count {min_alternate_count} \
		--pooled-discrete \
		-b {' -b '.join(bam_files)} \
	| bcftools view \
		--output-type z \
		--output {output_directory}/raw_vcf/all/tmp/{species_abbreviation(species_name)}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.prog.vcf.gz \
		--write-index \
		-
	
	mv {output_directory}/raw_vcf/all/tmp/{species_abbreviation(species_name)}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.prog.vcf.gz {outputs['vcf']}
	mv {output_directory}/raw_vcf/all/tmp/{species_abbreviation(species_name)}.freebayes_n{best_n_alleles}_p{ploidy}_minaltfrc{min_alternate_fraction}_minaltcnt{min_alternate_count}.{num}_{region}.prog.vcf.gz.csi {outputs['index']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def concat(files: list, output_name: str, output_directory: str = None, compress: bool = False):
	"""
	Template: Name-sorts and concatenates files. Optionally compresses output using :script:`gzip`.
	
	Template I/O::
	
		inputs = {'files': files}
		outputs = {'concat_file': output_name.ext | output_name.ext.gzip}
	
	:param list files:
		List containing files to concatenate.
	:param str output_name:
		Desired name of output file, no extension.
	:param str output_directory:
		Path to output directory. Default is directory of 'files[0]'.
	:param bool compress:
		Bool indicating whether the output file should be compressed or not.
	"""
	if output_directory is None:
		output_directory = os.path.dirname(files[0])
	inputs = {'files': files}
	if compress:
		outputs = {'concat_file': f'{output_directory}/{output_name}{os.path.splitext(files[0])[1]}.gz'}
	else:
		outputs = {'concat_file': f'{output_directory}/{output_name}{os.path.splitext(files[0])[1]}'}
	options = {
		'cores': 2,
		'memory': '16g',
		'walltime': '24:00:00'
	}
	protect = outputs['concat_file']
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {output_directory}] || mkdir -p {output_directory}

	if [ {compress} == 'False' ]; then
		cat \
			{' '.join(files)} \
			> {output_directory}/{output_name}.prog{os.path.splitext(files[0])[1]}
		
		mv {output_directory}/{output_name}.prog{os.path.splitext(files[0])[1]} {outputs['concat_file']}
	else
		cat \
			{' '.join(files)} \
		| gzip \
			-c \
			- \
			> {output_directory}/{output_name}.prog{os.path.splitext(files[0])[1]}.gz
		
		mv {output_directory}/{output_name}.prog{os.path.splitext(files[0])[1]}.gz {outputs['concat_file']}
	fi

	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, protect=protect, spec=spec)

def concat_vcf(files: list, output_name: str, output_directory: str = None, compress: bool = True):
	"""
	Template: Concatenates :format:`VCF` files. Optionally compresses output.
	
	Template I/O::
	
		inputs = {'files': files}
		outputs = {'concat_file': output_name.ext | output_name.ext.gzip}
	
	:param list files:
		List containing :format:`VCF` files to concatenate. Can already be gzipped.
	:param str output_name:
		Desired name of output file, no extension.
	:param str output_directory:
		Path to output directory. Default is directory of 'files[0]'.
	:param bool compress:
		Bool indicating whether the output file should be compressed or not.
	"""
	if not output_directory:
		output_directory = os.path.dirname(files[0])
	inputs = {'files': files}
	if compress:
		outputs = {'concat_file': f'{output_directory}/{output_name}.vcf.gz'}
	else:
		outputs = {'concat_file': f'{output_directory}/{output_name}.vcf'}
	options = {
		'cores': 32,
		'memory': '40g',
		'walltime': '24:00:00'
	}
	protect = outputs['concat_file']
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {output_directory} ] || mkdir -p {output_directory}
	
	if [ {compress} == 'False' ]; then
		bcftools concat \
			--threads {options['cores']} \
			--output-type v \
			--output {output_directory}/{output_name}.prog.vcf \
			{' '.join(files)}

			mv {output_directory}/{output_name}.prog.vcf {outputs['concat_file']}
	else
		bcftools concat \
			--threads {options['cores']} \
			--output-type z \
			--output {output_directory}/{output_name}.prog.vcf.gz \
			--write-index \
			{' '.join(files)}

			mv {output_directory}/{output_name}.prog.vcf.gz {outputs['concat_file']}
			mv {output_directory}/{output_name}.prog.vcf.gz.csi {output_directory}/{output_name}.vcf.gz.csi
	fi
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, protect=protect, spec=spec)

def merge_vcf(vcf_files: list, output_directory: str, species_name: str):
	"""
	Template: template_description
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'vcfs': vcf_files}
	outputs = {'vcf': f'{output_directory}/{species_abbreviation(species_name)}.{os.path.splitext(os.path.splitext(vcf_files[0])[0])[0] if vcf_files[0].endswith('.gz') else os.path.splitext(vcf_files[0])[0]}.merged.vcf.gz'}
	options = {
		'cores': 30,
		'memory': '40g',
		'walltime': '12:00:00'
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {output_directory} ] || mkdir -p {output_directory}
	
	bcftools merge \
		--threads {options['cores']} \
		--output-type z \
		--output {output_directory}/{species_abbreviation(species_name)}.{os.path.splitext(os.path.splitext(vcf_files[0])[0])[0] if vcf_files[0].endswith('.gz') else os.path.splitext(vcf_files[0])[0]}.merged.prog.vcf.gz \
		--missing-to-ref \
		--write-index \
		{' '.join(vcf_files)}
	
	mv {output_directory}/{species_abbreviation(species_name)}.{os.path.splitext(os.path.splitext(vcf_files[0])[0])[0] if vcf_files[0].endswith('.gz') else os.path.splitext(vcf_files[0])[0]}.merged.prog.vcf.gz {outputs['vcf']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def filter_vcf(vcf_file: str, output_directory: str, sample_group: str, sample_name: str, min_depth: int = 300, max_depth: int = 600):
	"""
	Template: template_description
	
	Template I/O::
	
		inputs = {}
		outputs = {}
	
	:param
	"""
	inputs = {'vcf': vcf_file}
	outputs = {'vcf': f'{output_directory}/{sample_group}/{sample_name}/{os.path.splitext(os.path.splitext(os.path.basename(vcf_file))[0])[0] if vcf_file.endswith(".gz") else os.path.splitext(os.path.basename(vcf_file))[0]}.bcftoolsfilter_SnpGap5_DP{min_depth}-{max_depth}_biallelic_AO1.vcf.gz',
			   'index': f'{output_directory}/{sample_group}/{sample_name}/{os.path.splitext(os.path.splitext(os.path.basename(vcf_file))[0])[0] if vcf_file.endswith(".gz") else os.path.splitext(os.path.basename(vcf_file))[0]}.bcftoolsfilter_SnpGap5_DP{min_depth}-{max_depth}_biallelic_AO1.vcf.gz.csi'}
	options = {
		'cores': 18,
		'memory': '20g',
		'walltime': '12:00:00'
	}
	spec = f"""
	# Sources environment
	if [ "$USER" == "jepe" ]; then
		source /home/"$USER"/.bashrc
		source activate popgen
	fi
	
	echo "START: $(date)"
	echo "JobID: $SLURM_JOBID"
	
	[ -d {output_directory}/{sample_group}/{sample_name} ] || mkdir -p {output_directory}/{sample_group}/{sample_name}
	
	bcftools filter \
		--threads {options['cores']} \
		--SnpGap 5:indel \
		--output-type u \
		{vcf_file} \
	| bcftools view \
		--threads {options['cores']} \
		--include 'FMT/DP>={min_depth} & FMT/DP<={max_depth}' \
		--output-type u \
		- \
	| bcftools view \
		--threads {options['cores']} \
		--max-alleles 2 \
		--types snps \
		--output-type u \
		- \
	| bcftools view \
		--threads {options['cores']} \
		--include 'AVG(FMT/AO) > 1' \
		--output-type z \
		--output {output_directory}/{sample_group}/{sample_name}/{os.path.splitext(os.path.splitext(os.path.basename(vcf_file))[0])[0] if vcf_file.endswith(".gz") else os.path.splitext(os.path.basename(vcf_file))[0]}.bcftoolsfilter_SnpGap5_DP{min_depth}-{max_depth}_biallelic_AO1.prog.vcf.gz \
		--write-index \
		-
	
	mv {output_directory}/{sample_group}/{sample_name}/{os.path.splitext(os.path.splitext(os.path.basename(vcf_file))[0])[0] if vcf_file.endswith(".gz") else os.path.splitext(os.path.basename(vcf_file))[0]}.bcftoolsfilter_SnpGap5_DP{min_depth}-{max_depth}_biallelic_AO1.prog.vcf.gz {outputs['vcf']}
	mv {output_directory}/{sample_group}/{sample_name}/{os.path.splitext(os.path.splitext(os.path.basename(vcf_file))[0])[0] if vcf_file.endswith(".gz") else os.path.splitext(os.path.basename(vcf_file))[0]}.bcftoolsfilter_SnpGap5_DP{min_depth}-{max_depth}_biallelic_AO1.prog.vcf.gz.csi {outputs['index']}
	
	echo "END: $(date)"
	echo "$(jobinfo "$SLURM_JOBID")"
	"""
	return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)