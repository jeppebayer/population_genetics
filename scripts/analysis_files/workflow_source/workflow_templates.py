#!/bin/env python3
from gwf import AnonymousTarget
import os, glob, re

########################## Functions ##########################

def species_abbreviation(species_name: str) -> str:
	"""Creates species abbreviation from species name.

	:param str species_name:
		Species name written as *genus* *species*"""
	genus, species = species_name.replace(' ', '_').split('_')
	genus = genus[0].upper() + genus[1:3]
	species = species[0].upper() + species[1:3]
	return genus + species

def parse_fasta(fasta_file: str):
    """
    Parses :format:`FASTA` file returning all sequence names and lengths paired in a list of dictionaries.
    
    ::
    
        return [{'sequence_name': str, 'sequence_length': int}, ...]
    
    :param str fasta_file:
        Sequence file in :format:`FASTA` format.
    """
    fasta_list = []
    seq_name = None
    length = 0
    with open(fasta_file, 'r') as fasta:
        for entry in fasta:
            entry = entry.strip()
            if entry.startswith(">"):
                if seq_name:
                    fasta_list.append({'sequence_name': seq_name, 'sequence_length': length})
                    length = 0
                entry = entry.split(" ", 1)
                seq_name = entry[0][1:]
            else:
                length += len(entry)
        fasta_list.append({'sequence_name': seq_name, 'sequence_length': length})
    return fasta_list

def padding_calculator(parse_fasta: list, size: int = 500000):
    """
    Calculates proper 0 padding for numbers in **partition_chrom**.

    :param list parse_fasta:
        List of dictionaries produced by **parse_fasta**.
    :param int size:
        Size of partitions. Default 500kb.
    """
    num = 1
    for chrom in parse_fasta:
        whole_chunks = chrom['sequence_length'] // size
        num += (whole_chunks + 1)
    return len(str(num))

def partition_chrom(parse_fasta: list, size: int = 500000, npad: int = 5):
    """
    Partitions :format:`FASTA` file parsed with **parse_fasta**.
    
    Uses the list of dictionaries from **parse_fasta** to creates a list of dictionaries
    containing partition number, sequence name, start and end postion (0 based).
    By default the partition size is 500kbs.
    
    ::
    
        return [{'num': int, 'region': str, 'start': int, 'end': int}, ...]
    
    :param list parse_fasta:
        List of dictionaries produced by **parse_fasta**.
    :param int size:
        Size of partitions. Default 500kb.
    """
    chrom_partition = []
    num = 1
    for chrom in parse_fasta:
        whole_chunks = chrom['sequence_length'] // size
        partial_chunk = chrom['sequence_length'] - whole_chunks * size
        start = 0
        for chunk in range(whole_chunks):
            end = start + size
            chrom_partition.append({'num': f'{num:0{npad}}', 'region': chrom['sequence_name'], 'start': start, 'end': end})
            start = end
            num += 1
        chrom_partition.append({'num': f'{num:0{npad}}', 'region': chrom['sequence_name'], 'start': start, 'end': start + partial_chunk})
        num += 1
    return chrom_partition

def mpileup_partitions_filelist(partitions: list, top_dir: str, species_name: str, npad: int = 5):
    """
    Generates list of dictionaries containing names of contigs and filenames of :format:`mpileup`-parts per contig based on **partition_chrom** output.

    Uses the list of dictionaries generated by **partition_chrom** to create a list of dictionaries where each dictionary contains the name of a contig
    and the names of output files created **mpileup_part** using those same partitions.

    ::

        return [{'contig': str, 'mpileup_files': list}, ...]
    
    :param list partitions:
        List of dictionaries produced by **partition_chrom**.
    :param str top_dir:
        Top most level of current working directory.
    :param str species_name:
        Name of species currently being worked on.
    """
    mpileup_filelists = []
    contig_name = None
    part_num = 0
    for partition in partitions:
        part_num += 1
        if partition['region'] != contig_name:
            if contig_name:
                mpileup_filelists.append({'contig': contig_name, 'mpileup_files': [f'{top_dir}/tmp/mpileup/{species_abbreviation(species_name)}_{num:0{npad}}_{contig_name}.mpileup' for num in range(start, part_num)]})
            start = part_num
            contig_name = partition['region']
    mpileup_filelists.append({'contig': contig_name, 'mpileup_files': [f'{top_dir}/tmp/mpileup/{species_abbreviation(species_name)}_{num:0{npad}}_{contig_name}.mpileup' for num in range(start, part_num + 1)]})
    return mpileup_filelists

########################## PoolSNP ##########################

def name_mpileup(idx: int, target: AnonymousTarget) -> str:
    return f'{os.path.basename(target.outputs["mpileup"])}'

def mpileup_parts(bam_files: list, reference_genome_file: str, species_name: str, region: str, num: int, start: int, end: int, output_directory: str):
    """
    Template: Create :format:`mpileup` files for each partition of reference genome from multiple :format:`BAM` files using :script:`samtools mpileup`.
    
    Template I/O::
    
        inputs = {'bam_files': bam_files,
                  'reference': reference_genome}
        outputs = {'mpileup': *_num_region.mpileup}
    
    :param list bam_files:
        List of all :format:`BAM` files to be included in :format:`mpileup` file.
    :param str reference_genome_file:
        Path to genome reference file in `FASTA`format.
    :param str species_name:
        Name of species being worked on.
    :param str region:
        Name of chromosome from **partition_chrom**.
    :param int num:
        Partition number from **partition_chrom**.
    :param int start:
        Start position from **partition_chrom**.
    :param int end:
        End position from **partition_chrom**.
    :param str output_directory:
        Path to output directory. Creates directories 'tmp/bed' and 'tmp/mpileup' at location.
    """
    inputs = {'bam_files': bam_files,
              'reference': reference_genome_file}
    outputs = {'mpileup': f'{output_directory}/tmp/mpileup/{species_abbreviation(species_name)}_{num}_{region}.mpileup',
               'bed': f'{output_directory}/tmp/bed/{num}.bed'}
    options = {
        'cores': 1,
        'memory': '16g',
        'walltime': '20:00:00'
    }
    spec = f"""
    # Sources environment
    if [ "$USER" == "jepe" ]; then
        source /home/"$USER"/.bashrc
        source activate vcf
    fi
    
    echo "START: $(date)"
    echo "JobID: $SLURM_JOBID"
    
    sleep 2m

    [ -d {output_directory}/tmp/bed ] || mkdir -p {output_directory}/tmp/bed
    [ -d {output_directory}/tmp/mpileup ] || mkdir -p {output_directory}/tmp/mpileup

    echo -e '{region}\t{start}\t{end}' > {output_directory}/tmp/bed/{num}.bed
    
    samtools mpileup \
        --max-depth 0 \
        --fasta-ref {reference_genome_file} \
        --positions {output_directory}/tmp/bed/{num}.bed \
        --min-BQ 0 \
        --region {region} \
        --output {output_directory}/tmp/mpileup/{species_abbreviation(species_name)}_{num}_{region}.prog.mpileup \
        {' '.join(bam_files)}
    
    mv {output_directory}/tmp/mpileup/{species_abbreviation(species_name)}_{num}_{region}.prog.mpileup {outputs['mpileup']}
    
    echo "END: $(date)"
    echo "$(jobinfo "$SLURM_JOBID")"
    """
    return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def name_sync(idx: int, target: AnonymousTarget) -> str:
    return f'{os.path.basename(target.outputs["sync"])}'

def mpileup2sync(mpileup_file: str, output_directory: str, mpileup2sync_script: str = glob.glob(f'{os.path.dirname(os.path.realpath(__file__))}/software/popoolation2*/mpileup2sync.pl')[0]):
    """
    Template: Makes a :format:`sync` file for a corresponding :format:`mpileup` file using :script:`popoolation2`'s :script:`mpileup2sync.pl`
    
    Template I/O::
    
        inputs = {'mpileup': mpileup_file}
        outputs = {'sync': *.sync,
                   'params': *.sync.params}
    
    :param str mpileup_file:
        Input :format:`mpileup` file.
    :param str output_directory:
        Output directory for :format:`sync` file. Creates directories 'tmp/sync/' at location.
    :param str mpileup2sync_script:
        Path to :script:`mpile2sync.pl`.
    """
    inputs = {'mpileup': mpileup_file}
    outputs = {'sync': f'{output_directory}/tmp/sync/{os.path.splitext(os.path.basename(mpileup_file))[0]}.sync',
               'params': f'{output_directory}/tmp/sync/{os.path.splitext(os.path.basename(mpileup_file))[0]}.sync.params'}
    options = {
        'cores': 2,
        'memory': '16g',
        'walltime': '20:00:00'
    }
    spec = f"""
    # Sources environment
    if [ "$USER" == "jepe" ]; then
        source /home/"$USER"/.bashrc
        source activate vcf
    fi
    
    echo "START: $(date)"
    echo "JobID: $SLURM_JOBID"
    
    [ -d {output_directory}/tmp/sync ] || mkdir -p {output_directory}/tmp/sync

    perl {mpileup2sync_script} \
        --input {mpileup_file} \
        --output {output_directory}/tmp/sync/{os.path.splitext(os.path.basename(mpileup_file))[0]}.prog.sync \
        --fastq-type sanger
    
    mv {output_directory}/tmp/sync/{os.path.splitext(os.path.basename(mpileup_file))[0]}.prog.sync {outputs['sync']}
    mv {output_directory}/tmp/sync/{os.path.splitext(os.path.basename(mpileup_file))[0]}.prog.sync.params {outputs['params']}

    echo "END: $(date)"
    echo "$(jobinfo "$SLURM_JOBID")"
    """
    return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def name_cov(idx: int, target: AnonymousTarget) -> str:
    return f'{os.path.basename(target.outputs["cutoff"])}'

def max_cov_threshold(mpileup_files: list, contig: str, cutoff: float, output_directory: str, max_cov_script: str = f'{os.path.dirname(os.path.realpath(__file__))}/software/PoolSNP/scripts/max-cov.py'):
    """
    Template: Calculates coverage thresholds using :script:`max-cov.py`.
    
    Template I/O::
    
        inputs = {'mpileups': mpileup_files}
        outputs = {'cutoff': output_directory/tmp/cov/cutoffs/contig.txt}
    
    :param str mpileup_file:
        List of input :format:`mpileup` files.
    :param str contig:
        Name of contig to be processed.
    :param float cutoff:
        Maximum coverage cutoff value. The maximum coverage percentile to be computed.
    :param str output_directory:
        Output directory for 'cutoff' file. Creates subdirectories tmp/cov/cutoffs/ at location.
    :param str max_cov_script:
        Path to PoolSNPs :script:`max-cov.py`.
    """
    mpileup_files.sort()
    inputs = {'mpileups': mpileup_files}
    outputs = {'cutoff': f'{output_directory}/tmp/cov/cutoffs/{contig}_maxcov{cutoff}.txt'}
    options = {
        'cores': 1,
        'memory': '10g',
        'walltime': '96:00:00'
    }
    spec = f"""
    # Sources environment
    if [ "$USER" == "jepe" ]; then
        source /home/"$USER"/.bashrc
        source activate vcf
    fi
    
    echo "START: $(date)"
    echo "JobID: $SLURM_JOBID"
    
    [ -d {output_directory}/tmp/cov/cutoffs ] || mkdir -p {output_directory}/tmp/cov/cutoffs

    if [ -s {mpileup_files[0]} ]; then
        python {max_cov_script} \
            --mpileup <(cat {" ".join(mpileup_files)})  \
            --cutoff {cutoff} \
            --contig {contig} \
            --out {output_directory}/tmp/cov/cutoffs/{contig}_maxcov{cutoff}.prog.txt
        
        mv {output_directory}/tmp/cov/cutoffs/{contig}_maxcov{cutoff}.prog.txt {outputs['cutoff']}
    else
        echo -n "" > {outputs['cutoff']}
    fi
    
    echo "END: $(date)"
    echo "$(jobinfo "$SLURM_JOBID")"
    """
    return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def max_cov(mpileup_file: str, contig: str, cutoff: float, output_directory: str, max_cov_script: str = f'{os.path.dirname(os.path.realpath(__file__))}/software/PoolSNP/scripts/max-cov.py'):
    """
    Template: Calculates coverage thresholds using :script:`max-cov.py`.
    
    Template I/O::
    
        inputs = {'mpileup': mpileup_file}
        outputs = {'cutoff': output_directory/tmp/cov/cutoffs/contig.txt}
    
    :param str mpileup_file:
        Input :format:`mpileup` file.
    :param str contig:
        Name of contig to be processed.
    :param float cutoff:
        Maximum coverage cutoff value. The maximum coverage percentile to be computed.
    :param str output_directory:
        Output directory for 'cutoff' file. Creates subdirectories tmp/cov/cutoffs/ at location.
    :param str max_cov_script:
        Path to PoolSNPs :script:`max-cov.py`.
    """
    inputs = {'mpileup': mpileup_file}
    outputs = {'cutoff': f'{output_directory}/tmp/cov/cutoffs/{contig}.txt'}
    options = {
        'cores': 1,
        'memory': '10g',
        'walltime': '96:00:00'
    }
    spec = f"""
    # Sources environment
    if [ "$USER" == "jepe" ]; then
        source /home/"$USER"/.bashrc
        source activate vcf
    fi
    
    echo "START: $(date)"
    echo "JobID: $SLURM_JOBID"
    
    [ -d {output_directory}/tmp/cov/cutoffs ] || mkdir -p {output_directory}/tmp/cov/cutoffs

    presence=$(awk -v contig={contig} 'BEGIN{{presence = "no"}} {{if ($1 == contig) {{presence = "yes"; exit}} }} END{{print presence}}' {mpileup_file})

    if [ "$presence" == "yes" ]; then
        awk \
            -v contig={contig} \
            '{{if ($1 == contig) {{print $0}}}}' \
            {mpileup_file} \
        | python {max_cov_script} \
            --mpileup - \
            --cutoff {cutoff} \
            --contig {contig} \
            --out {output_directory}/tmp/cov/cutoffs/{contig}.prog.txt
        
        mv {output_directory}/tmp/cov/cutoffs/{contig}.prog.txt {outputs['cutoff']}
    else
        echo -n "" > {outputs['cutoff']}
    fi
    
    echo "END: $(date)"
    echo "$(jobinfo "$SLURM_JOBID")"
    """
    return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, spec=spec)

def concat(files: list, output_name: str, output_directory: str = None, compress: bool = False):
    """
    Template: Name-sorts and concatenates files. Optionally compresses output using :script:`gzip`.
    
    Template I/O::
    
        inputs = {'files': files}
        outputs = {'concat_file': output_name.ext | output_name.ext.gzip}
    
    :param list files:
        List containing files to concatenate.
    :param str output_name:
        Desired name of output file, no extension.
    :param str output_directory:
        Path to output directory. Default is directory of 'files[0]'.
    :param bool compress:
        Bool indicating whether the output file should be compressed or not.
    """
    if output_directory is None:
        output_directory = os.path.dirname(files[0])
    inputs = {'files': files}
    if compress:
        outputs = {'concat_file': f'{output_directory}/{output_name}{os.path.splitext(files[0])[1]}.gz'}
    else:
        outputs = {'concat_file': f'{output_directory}/{output_name}{os.path.splitext(files[0])[1]}'}
    options = {
        'cores': 2,
        'memory': '16g',
        'walltime': '24:00:00'
    }
    protect = outputs['concat_file']
    spec = f"""
    # Sources environment
    if [ "$USER" == "jepe" ]; then
        source /home/"$USER"/.bashrc
        source activate vcf
    fi
    
    echo "START: $(date)"
    echo "JobID: $SLURM_JOBID"
    
    [ -d {output_directory}] || mkdir -p {output_directory}

    if [ {compress} == 'False' ]; then
        cat \
            {' '.join(files)} \
            > {output_directory}/{output_name}.prog{os.path.splitext(files[0])[1]}
        
        mv {output_directory}/{output_name}.prog{os.path.splitext(files[0])[1]} {outputs['concat_file']}
    else
        cat \
            {' '.join(files)} \
        | gzip \
            -c \
            - \
            > {output_directory}/{output_name}.prog{os.path.splitext(files[0])[1]}.gz
        
        mv {output_directory}/{output_name}.prog{os.path.splitext(files[0])[1]}.gz {outputs['concat_file']}
    fi

    echo "END: $(date)"
    echo "$(jobinfo "$SLURM_JOBID")"
    """
    return AnonymousTarget(inputs=inputs, outputs=outputs, options=options, protect=protect, spec=spec)

def poolsnp(mpileup_file: str, max_cov_file: str, sample_list: list, reference_genome_file: str, working_directory: str, species_name: str, output_directory: str = None, min_cov: int = 10, min_count: int = 3, min_freq: float = 0.01, miss_frac: float = 0.1, bq: int = 15, sites: int = 1, poolsnp_script: str = f'{os.path.dirname(os.path.realpath(__file__))}/software/PoolSNP/scripts/PoolSnp.py'):
    """
    Template: Creates :format:`VCF` file using :script:`PoolSnp.py`.
    
    Template I/O::
    
        inputs = {'mpileup': mpileup_file,
                  'max_cov': max_cov_file}
        outputs = {'vcf': *.vcf.gz}
    
    :param str mpileup_file:
        Input :format:`mpileup` file.
    :param str max_cov_file:
        Maximum coverage cutoff file produced by PoolSNPs :script:`max-cov.py`.
    :param list sample_list:
        List of all samples names in the :format:`mpileup` file.
    :param str reference_genome_file:
        Path to genome reference file in `FASTA` format.
    :param str working_directory:
        Path to directory for intermediary files.
    :param str species_name:
        Name of species being worked on.
    :param output directory:
        Path to output directory for :format:`VCF` file. Defaults to working directory.
    :param int min_cov:
        Sample-wise minimum coverage. Default 10.
    :param int min_count:
        Minimum alternative allele count across all populations pooled. Default 3.
    :param float min_freq:
        Minimum alternative allele frequency across all populations pooled. Default 0.01.
    :param float miss_frac:
        Maximum allowed fraction of samples not fullfilling all parameters. Default 0.1.
    :param int bq:
        Minimum base quality for every nucleotide. Default 15.
    :param int sites:
        Include all sites (1) or only polymorphic sites (0). Default 1.
    :param str poolsnp_script:
        Path to PoolSNPs :script:`PoolSnp.py`.
    """
    if output_directory is None:
        output_directory = working_directory
    sample_string = '\t'.join(sample_list)
    if sites == 1:
        sitestate = 'allsites'
    elif sites == 0:
        sitestate = 'variants'
    inputs = {'mpileup': mpileup_file,
              'max_cov': max_cov_file}
    outputs = {'vcf': f'{output_directory}/{species_abbreviation(species_name)}.{sitestate}_maxcov{os.path.splitext(max_cov_file)[0].split(sep = "-")[-1]}_mincov{min_cov}_mincnt{min_count}_minfrq{min_freq}_missfrc{miss_frac}_bq{bq}.vcf.gz'}
    protect = outputs['vcf']
    options = {
        'cores': 40,
        'memory': '160g',
        'walltime': '60:00:00'
    }
    spec = f"""
    # Sources environment
    if [ "$USER" == "jepe" ]; then
        source /home/"$USER"/.bashrc
        source activate vcf
    fi
    
    echo "START: $(date)"
    echo "JobID: $SLURM_JOBID"
    
    [ -d {working_directory}/tmp ] || mkdir -p {working_directory}/tmp
    [ -d {output_directory} ] || mkdir -p {output_directory}

    headerfile={working_directory}/tmp/header.{sitestate}_{os.path.splitext(max_cov_file)[0].split(sep = "-")[-1]}_{min_cov}_{min_count}_{min_freq}_{miss_frac}_{bq}.txt
    echo -e "##fileformat=VCFv4.2" > "$headerfile"
    echo -e "##fileDate=$(date +%d'/'%m'/'%y)" >> "$headerfile"
    echo -e "##Source=PoolSnp-1.05" >> "$headerfile"
    echo -e "##Parameters=<ID=MinCov,Number={min_cov},Type=Integer,Description=\\"Minimum coverage per sample\\">" >> "$headerfile"
    echo -e "##Parameters=<ID=MaxCov,Number={max_cov_file},Type=Integer,Description=\\"Maximum chromosome- and sample-specific maximum coverage; Either a precomputed file or the maximum percentile cutoff, eg. 0.95 to consider only reads within the 95% coverage percentile\\">" >> "$headerfile"
    echo -e "##Parameters=<ID=MinCount,Number={min_count},Type=Integer,Description=\\"Minimum alternative allele count across all samples pooled\\">" >> "$headerfile"
    echo -e "##Parameters=<ID=MinFreq,Number={min_freq},Type=Float,Description=\\"Minimum alternative allele frequency across all samples pooled\\">" >> "$headerfile"
    echo -e "##Parameters=<ID=MaximumMissingFraction,Number={miss_frac},Type=Float,Description=\\"Maximum fraction of samples allowed that are not fullfilling all parameters\\">" >> "$headerfile"
    echo -e "##Parameters=<ID=BaseQual,Number={bq},Type=Integer,Description=\\"Minimum PHRED scaled base quality\\">" >> "$headerfile"
    echo -e "##Reference={reference_genome_file}" >> "$headerfile"
    echo -e "##INFO=<ID=ADP,Number=1,Type=Integer,Description=\\"Average per-sample depth of bases with Phred score >={bq}\\">" >> "$headerfile"
    echo -e "##INFO=<ID=NC,Number=1,Type=Integer,Description=\\"Number of samples not called\\">" >> "$headerfile"
    echo -e "##FORMAT=<ID=GT,Number=1,Type=String,Description=\\"Genotype\\">" >> "$headerfile"
    echo -e "##FORMAT=<ID=RD,Number=1,Type=Integer,Description=\\"Reference Counts\\">" >> "$headerfile"
    echo -e "##FORMAT=<ID=AD,Number=1,Type=Integer,Description=\\"Alternative Counts\\">" >> "$headerfile"
    echo -e "##FORMAT=<ID=DP,Number=1,Type=Integer,Description=\\"Total Depth\\">" >> "$headerfile"
    echo -e "##FORMAT=<ID=FREQ,Number=1,Type=Float,Description=\\"Variant allele frequency\\">" >> "$headerfile"
    echo -e "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\t{sample_string}" >> "$headerfile"

    parallel \
        -k \
        -j {options['cores']} \
        --pipepart \
        --no-notice \
        -a {mpileup_file} \
    --cat python {poolsnp_script} \
        --mpileup {{}} \
        --min-cov {min_cov} \
        --max-cov {max_cov_file} \
        --min-freq {min_freq} \
        --miss-frac {miss_frac} \
        --min-count {min_count} \
        --base-quality {bq} \
        --allsites {sites} \
        > {working_directory}/tmp/SNPs.{sitestate}_{os.path.splitext(max_cov_file)[0].split(sep = "-")[-1]}_{min_cov}_{min_count}_{min_freq}_{miss_frac}_{bq}.txt

    cat \
        {working_directory}/tmp/header.{sitestate}_{os.path.splitext(max_cov_file)[0].split(sep = "-")[-1]}_{min_cov}_{min_count}_{min_freq}_{miss_frac}_{bq}.txt \
        {working_directory}/tmp/SNPs.{sitestate}_{os.path.splitext(max_cov_file)[0].split(sep = "-")[-1]}_{min_cov}_{min_count}_{min_freq}_{miss_frac}_{bq}.txt \
    | gzip \
        > {output_directory}/{species_abbreviation(species_name)}.{sitestate}_maxcov{os.path.splitext(max_cov_file)[0].split(sep = "-")[-1]}_mincov{min_cov}_mincnt{min_count}_minfrq{min_freq}_missfrc{miss_frac}_bq{bq}.prog.vcf.gz
    
    mv {output_directory}/{species_abbreviation(species_name)}.{sitestate}_maxcov{os.path.splitext(max_cov_file)[0].split(sep = "-")[-1]}_mincov{min_cov}_mincnt{min_count}_minfrq{min_freq}_missfrc{miss_frac}_bq{bq}.prog.vcf.gz \
        {outputs['vcf']}

    rm -f {working_directory}/tmp/header.{sitestate}_{os.path.splitext(max_cov_file)[0].split(sep = "-")[-1]}_{min_cov}_{min_count}_{min_freq}_{miss_frac}_{bq}.txt
    rm -f {working_directory}/tmp/SNPs.{sitestate}_{os.path.splitext(max_cov_file)[0].split(sep = "-")[-1]}_{min_cov}_{min_count}_{min_freq}_{miss_frac}_{bq}.txt

    echo "END: $(date)"
    echo "$(jobinfo "$SLURM_JOBID")"
    """
    return AnonymousTarget(inputs=inputs, outputs=outputs, protect=protect, options=options, spec=spec)

def vcf_filter(vcf_file: str, output_directory: str, species_name: str):
    """
    Template: Filter :format:`VCF` file turning it into a biallelic format.
    
    Template I/O::
    
        inputs = {'vcf': vcf_file}
        outputs = {'biallelic': *.biallelic.vcf.gz}
    
    :param str vcf_file:
        Input :format:`VCF` file.
    :param str output_directory:
        Output directory for biallelic :format:`VCF` file.
    :param str species_name:
        Name species currently being worked on.
    """
    inputs = {'vcf': vcf_file}
    if vcf_file.endswith('.gz'):
        outputs = {'biallelic': f'{output_directory}/{os.path.basename(os.path.splitext(os.path.splitext(vcf_file)[0])[0])}.biallelic.vcf.gz'}
        vcf_file=f'<(zcat {vcf_file})'
    else:
        outputs = {'biallelic': f'{output_directory}/{os.path.basename(os.path.splitext(vcf_file)[0])}.biallelic.vcf.gz'}
    protect = outputs['biallelic']
    options = {
        'cores': 1,
        'memory': '10g',
        'walltime': '12:00:00'
    }
    spec = f"""
    # Sources environment
    if [ "$USER" == "jepe" ]; then
        source /home/"$USER"/.bashrc
        source activate vcf
    fi
    
    echo "START: $(date)"
    echo "JobID: $SLURM_JOBID"

    [ -d {output_directory} ] || mkdir -p {output_directory}

    awk \
        'BEGIN{{FS=OFS="\\t"}}
        {{
        if ($0 ~ /^#/)
        	{{print $0}}
        else
        	{{len=length($5)
        	if ($5 !=  "." && len == 1)
        		{{for(i=1;i<=NF;i++)
        			{{if (substr($i,1,3)=="0/1" && substr($i,length($i)-2,3)=="0.0") 
        				{{sub("0/1", "0/0", $i)}}
        			}}; print
        		}}
        	else
        		{{if ($5 !=  "." && len == 3)
        			{{for(i=1;i<=NF;i++)
        				{{if (substr($i,1,4)=="0/1:" && substr($i,length($i)-2,3)=="0.0")
        					{{sub("0/1", "0/0", $i)}}
        				if (substr($i,1,4)=="0/2:" && substr($i,length($i)-2,3)=="0.0")
        					{{sub("0/2", "0/0", $i)}}
        				if (substr($i,1,6)=="0/1/2:" && substr($i,length($i)-6,7)=="0.0,0.0")
        					{{sub("0/1/2", "0/0", $i)}}
        				if (substr($i,1,6)=="0/1/2:" && substr($i,length($i)-2,3)=="0.0" && substr($i,length($i)-6,3)!="0.0")
        					{{sub("0/1/2", "0/1", $i)}}
        				if (substr($i,1,6)=="0/1/2:" && substr($i,length($i)-7,3)=="0.0" && substr($i,length($i)-2,3)!="0.0")
        					{{sub("0/1/2", "0/2", $i)}}
        				}}; print
        			}}
        		else
        			{{if ($5 !=  "." && len == 5)
        				{{for(i=1;i<=NF;i++)
        					{{if (substr($i,1,4)=="0/1:"  && substr($i,length($i)-2,3)=="0.0")
        						{{sub("0/1", "0/0", $i)}}
        					if (substr($i,1,4)=="0/2:" && substr($i,length($i)-2,3)=="0.0")
        						{{sub("0/2", "0/0", $i)}}
        					if (substr($i,1,4)=="0/3:" && substr($i,length($i)-2,3)=="0.0")
        						{{sub("0/3", "0/0", $i)}}
        					if (substr($i,1,6)=="0/1/2:" && substr($i,length($i)-6,7)=="0.0,0.0")
        						{{sub("0/1/2", "0/0", $i)}}
        					if (substr($i,1,6)=="0/1/2:" && substr($i,length($i)-2,3)=="0.0" && substr($i,length($i)-6,3)!="0.0")
        						{{sub("0/1/2", "0/1", $i)}}
        					if (substr($i,1,6)=="0/1/2:"&& substr($i,length($i)-7,3)=="0.0" && substr($i,length($i)-2,3)!="0.0")
        						{{sub("0/1/2", "0/2", $i)}}
        					if (substr($i,1,6)=="0/1/3:" && substr($i,length($i)-6,7)=="0.0,0.0")
        						{{sub("0/1/3", "0/0", $i)}}
        					if (substr($i,1,6)=="0/1/3:" && substr($i,length($i)-2,3)=="0.0" && substr($i,length($i)-6,3)!="0.0")
        						{{sub("0/1/3", "0/1", $i)}}
        					if (substr($i,1,6)=="0/1/3:" && substr($i,length($i)-7,3)=="0.0" && substr($i,length($i)-2,3)!="0.0")
        						{{sub("0/1/3", "0/3", $i)}}
        					if (substr($i,1,6)=="0/2/3:" && substr($i,length($i)-6,7)=="0.0,0.0")
        						{{sub("0/2/3", "0/0", $i)}}
        					if (substr($i,1,6)=="0/2/3:" && substr($i,length($i)-2,3)=="0.0" && substr($i,length($i)-6,3)!="0.0")
        						{{sub("0/2/3", "0/2", $i)}}
        					if (substr($i,1,6)=="0/2/3:" && substr($i,length($i)-7,3)=="0.0" && substr($i,length($i)-2,3)!="0.0")
        						{{sub("0/2/3", "0/3", $i)}}
        					if (substr($i,1,8)=="0/1/2/3:" && substr($i,length($i)-10,11)=="0.0,0.0,0.0") 
        						{{sub("0/1/2/3", "0/0", $i)}}
        					if (substr($i,1,8)=="0/1/2/3:" && substr($i,length($i)-6,7)=="0.0,0.0" && substr($i,length($i)-10,3)!="0.0") 
        						{{sub("0/1/2/3", "0/1", $i)}}
        					if (substr($i,1,8)=="0/1/2/3:" && substr($i,length($i)-2,3)=="0.0" && substr($i,length($i)-11,3)=="0.0" && substr($i,length($i)-6,3)!="0.0")
        						{{sub("0/1/2/3", "0/2", $i)}}
        					if (substr($i,1,8)=="0/1/2/3:" && substr($i,length($i)-11,7)=="0.0,0.0" && substr($i,length($i)-2,3)!="0.0")
        						{{sub("0/1/2/3", "0/3", $i)}}
        					}}; print
        				}}
        			else {{print $0}}
        			}}
        		}}
        	}}
        }}' {vcf_file} \
    | awk \
        'BEGIN{{FS=OFS="\\t"}}
        {{
        if ($0 ~ /^#/)
        	{{print $0}}
        else
        	{{len=length($5)
        	if ($5 !=  "." && len == 3)
        		{{for(i=1;i<=NF;i++)
        			{{if (substr($i,1,4)=="0/0:" && substr($i,length($i)-6,7)=="0.0,0.0")
        				{{sub("0.0,0.0", "0.0", $i)}}
        			if (substr($i,1,4)=="0/1:" && substr($i,length($i)-2,3)=="0.0")
        				{{sub(",0.0", "", $i)}}
        			if (substr($i,1,4)=="0/2:" && substr($i,length($i)-2,3)!="0.0")
        				{{sub("0.0,", "", $i)}}
        			}}; print
        		}}
        	else
        		{{if ($5 !=  "." && len == 5)
        			{{for(i=1;i<=NF;i++)
        				{{if (substr($i,1,4)=="0/0:"  && substr($i,length($i)-7,8)==":0.0,0.0")
        					{{sub("0.0,0.0", "0.0", $i)}}
        				if (substr($i,1,4)=="0/0:" && substr($i,length($i)-10,11)=="0.0,0.0,0.0")
        					{{sub("0.0,0.0,0.0", "0.0", $i)}}
        				if (substr($i,1,4)=="0/1:" && substr($i,length($i)-2,3)=="0.0" && substr($i,length($i)-6,3)!="0.0")
        					{{sub(",0.0", "", $i)}}
        				if (substr($i,1,4)=="0/2:" && substr($i,length($i)-2,3)!="0.0")
        					{{sub("0.0,", "", $i)}}
        				if (substr($i,1,4)=="0/3:" && substr($i,length($i)-2,3)!="0.0" && substr($i,length($i)-8,4)==":0.0")
        					{{sub("0.0,", "", $i)}}
        				if (substr($i,1,4)=="0/2:"&& substr($i,length($i)-2,3)=="0.0" && substr($i,length($i)-6,3)!="0.0" && substr($i,length($i)-8,1)==":")
        					{{sub(",0.0", "", $i)}}
        				if (substr($i,1,4)=="0/1:" && substr($i,length($i)-6,7)=="0.0,0.0")
        					{{sub(",0.0,0.0", "", $i)}}
        				if (substr($i,1,4)=="0/2:" && substr($i,length($i)-2,3)=="0.0" && substr($i,length($i)-11,3)=="0.0" && substr($i,length($i)-6,3)!="0.0")
        					{{sub("0.0,", "", $i); sub(",0.0", "", $i)}}
        				if (substr($i,1,4)=="0/3:" && substr($i,length($i)-2,3)!="0.0")
        					{{sub("0.0,0.0,", "", $i)}}
        				}}; print
        			}}
        		else {{print $0}}
        		}}
        	}}
        }}' \
    | awk \
        'BEGIN{{FS=OFS="\\t"}}
        {{
        if ($0 ~ /^#/)
        	{{print $0}}
        else
        	{{ONE = 0; TWO = 0; THREE = 0
        	if ($0 ~ /\/1/)
        		{{ONE = 1}}
        	if ($0 ~ /\/2/)
        		{{TWO = 1}}
        	if ($0 ~ /\/3/)
        		{{THREE = 1}}
        	if (ONE + TWO + THREE == 0)
        		{{sub($5,".", $5); print $0}}
        	if (ONE + TWO + THREE >= 2)
        		{{next}}
        	else
        		{{if (ONE == 1)
        			{{sub($5,substr($5,1,1),$5); print $0}}
        		else
        			{{if (TWO == 1)
        				{{sub($5,substr($5,3,1),$5); print $0}}
        			else
        				{{if (THREE == 1)
        					{{sub($5,substr($5,5,1),$5); print $0}}
        				}}
        			}}
        		}}
        	}}
        }}' \
    | awk \
        'BEGIN{{FS=OFS="\\t"}}
        {{
        if ($0 ~ /^#/)
        	{{print $0}}
        else
        	{{gsub("/2","/1"); print $0}}
        }}' \
    | awk \
        'BEGIN{{FS=OFS="\\t"}}
        {{
        if ($0 ~ /^#/)
        	{{print $0}}
        else
        	{{gsub("/3","/1"); print $0}}
        }}' \
    | gzip > {output_directory}/{species_abbreviation(species_name)}.biallelic.prog.vcf.gz
    
    mv {output_directory}/{species_abbreviation(species_name)}.biallelic.prog.vcf.gz {outputs['biallelic']}
    
    echo "END: $(date)"
    echo "$(jobinfo "$SLURM_JOBID")"
    """
    return AnonymousTarget(inputs=inputs, outputs=outputs, protect=protect, options=options, spec=spec)